// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/lockup/query.proto" (package "osmosis.lockup", syntax proto3),// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SyntheticLock } from "./lock";
import { Duration } from "../../google/protobuf/duration";
import { PeriodLock } from "./lock";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Coin } from "../../cosmos/base/v1beta1/coin";
/**
 * @generated from protobuf message osmosis.lockup.ModuleBalanceRequest
 */
export interface ModuleBalanceRequest {
}
/**
 * @generated from protobuf message osmosis.lockup.ModuleBalanceResponse
 */
export interface ModuleBalanceResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.lockup.ModuleLockedAmountRequest
 */
export interface ModuleLockedAmountRequest {
}
/**
 * @generated from protobuf message osmosis.lockup.ModuleLockedAmountResponse
 */
export interface ModuleLockedAmountResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockableCoinsRequest
 */
export interface AccountUnlockableCoinsRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockableCoinsResponse
 */
export interface AccountUnlockableCoinsResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockingCoinsRequest
 */
export interface AccountUnlockingCoinsRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockingCoinsResponse
 */
export interface AccountUnlockingCoinsResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedCoinsRequest
 */
export interface AccountLockedCoinsRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedCoinsResponse
 */
export interface AccountLockedCoinsResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeRequest
 */
export interface AccountLockedPastTimeRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2;
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeResponse
 */
export interface AccountLockedPastTimeResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyRequest
 */
export interface AccountLockedPastTimeNotUnlockingOnlyRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2;
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyResponse
 */
export interface AccountLockedPastTimeNotUnlockingOnlyResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockedBeforeTimeRequest
 */
export interface AccountUnlockedBeforeTimeRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2;
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountUnlockedBeforeTimeResponse
 */
export interface AccountUnlockedBeforeTimeResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeDenomRequest
 */
export interface AccountLockedPastTimeDenomRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2;
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: string denom = 3;
     */
    denom: string;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedPastTimeDenomResponse
 */
export interface AccountLockedPastTimeDenomResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.LockedDenomRequest
 */
export interface LockedDenomRequest {
    /**
     * @generated from protobuf field: string denom = 1;
     */
    denom: string;
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
}
/**
 * @generated from protobuf message osmosis.lockup.LockedDenomResponse
 */
export interface LockedDenomResponse {
    /**
     * @generated from protobuf field: string amount = 1;
     */
    amount: string;
}
/**
 * @generated from protobuf message osmosis.lockup.LockedRequest
 */
export interface LockedRequest {
    /**
     * @generated from protobuf field: uint64 lock_id = 1;
     */
    lockId: bigint;
}
/**
 * @generated from protobuf message osmosis.lockup.LockedResponse
 */
export interface LockedResponse {
    /**
     * @generated from protobuf field: osmosis.lockup.PeriodLock lock = 1;
     */
    lock?: PeriodLock;
}
/**
 * @generated from protobuf message osmosis.lockup.SyntheticLockupsByLockupIDRequest
 */
export interface SyntheticLockupsByLockupIDRequest {
    /**
     * @generated from protobuf field: uint64 lock_id = 1;
     */
    lockId: bigint;
}
/**
 * @generated from protobuf message osmosis.lockup.SyntheticLockupsByLockupIDResponse
 */
export interface SyntheticLockupsByLockupIDResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.SyntheticLock synthetic_locks = 1;
     */
    syntheticLocks: SyntheticLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationRequest
 */
export interface AccountLockedLongerDurationRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationResponse
 */
export interface AccountLockedLongerDurationResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyRequest
 */
export interface AccountLockedLongerDurationNotUnlockingOnlyRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyResponse
 */
export interface AccountLockedLongerDurationNotUnlockingOnlyResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationDenomRequest
 */
export interface AccountLockedLongerDurationDenomRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 2;
     */
    duration?: Duration;
    /**
     * @generated from protobuf field: string denom = 3;
     */
    denom: string;
}
/**
 * @generated from protobuf message osmosis.lockup.AccountLockedLongerDurationDenomResponse
 */
export interface AccountLockedLongerDurationDenomResponse {
    /**
     * @generated from protobuf field: repeated osmosis.lockup.PeriodLock locks = 1;
     */
    locks: PeriodLock[];
}
// @generated message type with reflection information, may provide speed optimized methods
class ModuleBalanceRequest$Type extends MessageType<ModuleBalanceRequest> {
    constructor() {
        super("osmosis.lockup.ModuleBalanceRequest", []);
    }
    create(value?: PartialMessage<ModuleBalanceRequest>): ModuleBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleBalanceRequest): ModuleBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ModuleBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.ModuleBalanceRequest
 */
export const ModuleBalanceRequest = new ModuleBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleBalanceResponse$Type extends MessageType<ModuleBalanceResponse> {
    constructor() {
        super("osmosis.lockup.ModuleBalanceResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<ModuleBalanceResponse>): ModuleBalanceResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleBalanceResponse): ModuleBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.ModuleBalanceResponse
 */
export const ModuleBalanceResponse = new ModuleBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleLockedAmountRequest$Type extends MessageType<ModuleLockedAmountRequest> {
    constructor() {
        super("osmosis.lockup.ModuleLockedAmountRequest", []);
    }
    create(value?: PartialMessage<ModuleLockedAmountRequest>): ModuleLockedAmountRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleLockedAmountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleLockedAmountRequest): ModuleLockedAmountRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ModuleLockedAmountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.ModuleLockedAmountRequest
 */
export const ModuleLockedAmountRequest = new ModuleLockedAmountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleLockedAmountResponse$Type extends MessageType<ModuleLockedAmountResponse> {
    constructor() {
        super("osmosis.lockup.ModuleLockedAmountResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<ModuleLockedAmountResponse>): ModuleLockedAmountResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleLockedAmountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleLockedAmountResponse): ModuleLockedAmountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleLockedAmountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.ModuleLockedAmountResponse
 */
export const ModuleLockedAmountResponse = new ModuleLockedAmountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockableCoinsRequest$Type extends MessageType<AccountUnlockableCoinsRequest> {
    constructor() {
        super("osmosis.lockup.AccountUnlockableCoinsRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockableCoinsRequest>): AccountUnlockableCoinsRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockableCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockableCoinsRequest): AccountUnlockableCoinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockableCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockableCoinsRequest
 */
export const AccountUnlockableCoinsRequest = new AccountUnlockableCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockableCoinsResponse$Type extends MessageType<AccountUnlockableCoinsResponse> {
    constructor() {
        super("osmosis.lockup.AccountUnlockableCoinsResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockableCoinsResponse>): AccountUnlockableCoinsResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockableCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockableCoinsResponse): AccountUnlockableCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockableCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockableCoinsResponse
 */
export const AccountUnlockableCoinsResponse = new AccountUnlockableCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockingCoinsRequest$Type extends MessageType<AccountUnlockingCoinsRequest> {
    constructor() {
        super("osmosis.lockup.AccountUnlockingCoinsRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockingCoinsRequest>): AccountUnlockingCoinsRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockingCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockingCoinsRequest): AccountUnlockingCoinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockingCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockingCoinsRequest
 */
export const AccountUnlockingCoinsRequest = new AccountUnlockingCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockingCoinsResponse$Type extends MessageType<AccountUnlockingCoinsResponse> {
    constructor() {
        super("osmosis.lockup.AccountUnlockingCoinsResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockingCoinsResponse>): AccountUnlockingCoinsResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockingCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockingCoinsResponse): AccountUnlockingCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockingCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockingCoinsResponse
 */
export const AccountUnlockingCoinsResponse = new AccountUnlockingCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedCoinsRequest$Type extends MessageType<AccountLockedCoinsRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedCoinsRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedCoinsRequest>): AccountLockedCoinsRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedCoinsRequest): AccountLockedCoinsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedCoinsRequest
 */
export const AccountLockedCoinsRequest = new AccountLockedCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedCoinsResponse$Type extends MessageType<AccountLockedCoinsResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedCoinsResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedCoinsResponse>): AccountLockedCoinsResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedCoinsResponse): AccountLockedCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedCoinsResponse
 */
export const AccountLockedCoinsResponse = new AccountLockedCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeRequest$Type extends MessageType<AccountLockedPastTimeRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"timestamp\"", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeRequest>): AccountLockedPastTimeRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeRequest): AccountLockedPastTimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeRequest
 */
export const AccountLockedPastTimeRequest = new AccountLockedPastTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeResponse$Type extends MessageType<AccountLockedPastTimeResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeResponse>): AccountLockedPastTimeResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeResponse): AccountLockedPastTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeResponse
 */
export const AccountLockedPastTimeResponse = new AccountLockedPastTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeNotUnlockingOnlyRequest$Type extends MessageType<AccountLockedPastTimeNotUnlockingOnlyRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"timestamp\"", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeNotUnlockingOnlyRequest>): AccountLockedPastTimeNotUnlockingOnlyRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeNotUnlockingOnlyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeNotUnlockingOnlyRequest): AccountLockedPastTimeNotUnlockingOnlyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeNotUnlockingOnlyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyRequest
 */
export const AccountLockedPastTimeNotUnlockingOnlyRequest = new AccountLockedPastTimeNotUnlockingOnlyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeNotUnlockingOnlyResponse$Type extends MessageType<AccountLockedPastTimeNotUnlockingOnlyResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeNotUnlockingOnlyResponse>): AccountLockedPastTimeNotUnlockingOnlyResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeNotUnlockingOnlyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeNotUnlockingOnlyResponse): AccountLockedPastTimeNotUnlockingOnlyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeNotUnlockingOnlyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeNotUnlockingOnlyResponse
 */
export const AccountLockedPastTimeNotUnlockingOnlyResponse = new AccountLockedPastTimeNotUnlockingOnlyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockedBeforeTimeRequest$Type extends MessageType<AccountUnlockedBeforeTimeRequest> {
    constructor() {
        super("osmosis.lockup.AccountUnlockedBeforeTimeRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"timestamp\"", "gogoproto.stdtime": true } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockedBeforeTimeRequest>): AccountUnlockedBeforeTimeRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockedBeforeTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockedBeforeTimeRequest): AccountUnlockedBeforeTimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockedBeforeTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockedBeforeTimeRequest
 */
export const AccountUnlockedBeforeTimeRequest = new AccountUnlockedBeforeTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUnlockedBeforeTimeResponse$Type extends MessageType<AccountUnlockedBeforeTimeResponse> {
    constructor() {
        super("osmosis.lockup.AccountUnlockedBeforeTimeResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountUnlockedBeforeTimeResponse>): AccountUnlockedBeforeTimeResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountUnlockedBeforeTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountUnlockedBeforeTimeResponse): AccountUnlockedBeforeTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountUnlockedBeforeTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountUnlockedBeforeTimeResponse
 */
export const AccountUnlockedBeforeTimeResponse = new AccountUnlockedBeforeTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeDenomRequest$Type extends MessageType<AccountLockedPastTimeDenomRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeDenomRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"timestamp\"", "gogoproto.stdtime": true } },
            { no: 3, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeDenomRequest>): AccountLockedPastTimeDenomRequest {
        const message = { owner: "", denom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeDenomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeDenomRequest): AccountLockedPastTimeDenomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* string denom */ 3:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeDenomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string denom = 3; */
        if (message.denom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeDenomRequest
 */
export const AccountLockedPastTimeDenomRequest = new AccountLockedPastTimeDenomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedPastTimeDenomResponse$Type extends MessageType<AccountLockedPastTimeDenomResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedPastTimeDenomResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedPastTimeDenomResponse>): AccountLockedPastTimeDenomResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedPastTimeDenomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedPastTimeDenomResponse): AccountLockedPastTimeDenomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedPastTimeDenomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedPastTimeDenomResponse
 */
export const AccountLockedPastTimeDenomResponse = new AccountLockedPastTimeDenomResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockedDenomRequest$Type extends MessageType<LockedDenomRequest> {
    constructor() {
        super("osmosis.lockup.LockedDenomRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "duration", kind: "message", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"duration\"", "gogoproto.stdduration": true } }
        ]);
    }
    create(value?: PartialMessage<LockedDenomRequest>): LockedDenomRequest {
        const message = { denom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockedDenomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockedDenomRequest): LockedDenomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockedDenomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* google.protobuf.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.LockedDenomRequest
 */
export const LockedDenomRequest = new LockedDenomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockedDenomResponse$Type extends MessageType<LockedDenomResponse> {
    constructor() {
        super("osmosis.lockup.LockedDenomResponse", [
            { no: 1, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"amount\"" } }
        ]);
    }
    create(value?: PartialMessage<LockedDenomResponse>): LockedDenomResponse {
        const message = { amount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockedDenomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockedDenomResponse): LockedDenomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amount */ 1:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockedDenomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amount = 1; */
        if (message.amount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.LockedDenomResponse
 */
export const LockedDenomResponse = new LockedDenomResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockedRequest$Type extends MessageType<LockedRequest> {
    constructor() {
        super("osmosis.lockup.LockedRequest", [
            { no: 1, name: "lock_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LockedRequest>): LockedRequest {
        const message = { lockId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockedRequest): LockedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 lock_id */ 1:
                    message.lockId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 lock_id = 1; */
        if (message.lockId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lockId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.LockedRequest
 */
export const LockedRequest = new LockedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockedResponse$Type extends MessageType<LockedResponse> {
    constructor() {
        super("osmosis.lockup.LockedResponse", [
            { no: 1, name: "lock", kind: "message", T: () => PeriodLock }
        ]);
    }
    create(value?: PartialMessage<LockedResponse>): LockedResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockedResponse): LockedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* osmosis.lockup.PeriodLock lock */ 1:
                    message.lock = PeriodLock.internalBinaryRead(reader, reader.uint32(), options, message.lock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* osmosis.lockup.PeriodLock lock = 1; */
        if (message.lock)
            PeriodLock.internalBinaryWrite(message.lock, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.LockedResponse
 */
export const LockedResponse = new LockedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyntheticLockupsByLockupIDRequest$Type extends MessageType<SyntheticLockupsByLockupIDRequest> {
    constructor() {
        super("osmosis.lockup.SyntheticLockupsByLockupIDRequest", [
            { no: 1, name: "lock_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SyntheticLockupsByLockupIDRequest>): SyntheticLockupsByLockupIDRequest {
        const message = { lockId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyntheticLockupsByLockupIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyntheticLockupsByLockupIDRequest): SyntheticLockupsByLockupIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 lock_id */ 1:
                    message.lockId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyntheticLockupsByLockupIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 lock_id = 1; */
        if (message.lockId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lockId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.SyntheticLockupsByLockupIDRequest
 */
export const SyntheticLockupsByLockupIDRequest = new SyntheticLockupsByLockupIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyntheticLockupsByLockupIDResponse$Type extends MessageType<SyntheticLockupsByLockupIDResponse> {
    constructor() {
        super("osmosis.lockup.SyntheticLockupsByLockupIDResponse", [
            { no: 1, name: "synthetic_locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SyntheticLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<SyntheticLockupsByLockupIDResponse>): SyntheticLockupsByLockupIDResponse {
        const message = { syntheticLocks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyntheticLockupsByLockupIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyntheticLockupsByLockupIDResponse): SyntheticLockupsByLockupIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.SyntheticLock synthetic_locks */ 1:
                    message.syntheticLocks.push(SyntheticLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyntheticLockupsByLockupIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.SyntheticLock synthetic_locks = 1; */
        for (let i = 0; i < message.syntheticLocks.length; i++)
            SyntheticLock.internalBinaryWrite(message.syntheticLocks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.SyntheticLockupsByLockupIDResponse
 */
export const SyntheticLockupsByLockupIDResponse = new SyntheticLockupsByLockupIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationRequest$Type extends MessageType<AccountLockedLongerDurationRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "duration", kind: "message", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"duration\"", "gogoproto.stdduration": true } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationRequest>): AccountLockedLongerDurationRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationRequest): AccountLockedLongerDurationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationRequest
 */
export const AccountLockedLongerDurationRequest = new AccountLockedLongerDurationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationResponse$Type extends MessageType<AccountLockedLongerDurationResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationResponse>): AccountLockedLongerDurationResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationResponse): AccountLockedLongerDurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationResponse
 */
export const AccountLockedLongerDurationResponse = new AccountLockedLongerDurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationNotUnlockingOnlyRequest$Type extends MessageType<AccountLockedLongerDurationNotUnlockingOnlyRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "duration", kind: "message", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"duration\"", "gogoproto.stdduration": true } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationNotUnlockingOnlyRequest>): AccountLockedLongerDurationNotUnlockingOnlyRequest {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationNotUnlockingOnlyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationNotUnlockingOnlyRequest): AccountLockedLongerDurationNotUnlockingOnlyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationNotUnlockingOnlyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyRequest
 */
export const AccountLockedLongerDurationNotUnlockingOnlyRequest = new AccountLockedLongerDurationNotUnlockingOnlyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationNotUnlockingOnlyResponse$Type extends MessageType<AccountLockedLongerDurationNotUnlockingOnlyResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationNotUnlockingOnlyResponse>): AccountLockedLongerDurationNotUnlockingOnlyResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationNotUnlockingOnlyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationNotUnlockingOnlyResponse): AccountLockedLongerDurationNotUnlockingOnlyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationNotUnlockingOnlyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationNotUnlockingOnlyResponse
 */
export const AccountLockedLongerDurationNotUnlockingOnlyResponse = new AccountLockedLongerDurationNotUnlockingOnlyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationDenomRequest$Type extends MessageType<AccountLockedLongerDurationDenomRequest> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationDenomRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "duration", kind: "message", T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"duration\"", "gogoproto.stdduration": true } },
            { no: 3, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationDenomRequest>): AccountLockedLongerDurationDenomRequest {
        const message = { owner: "", denom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationDenomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationDenomRequest): AccountLockedLongerDurationDenomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                case /* string denom */ 3:
                    message.denom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationDenomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string denom = 3; */
        if (message.denom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.denom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationDenomRequest
 */
export const AccountLockedLongerDurationDenomRequest = new AccountLockedLongerDurationDenomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountLockedLongerDurationDenomResponse$Type extends MessageType<AccountLockedLongerDurationDenomResponse> {
    constructor() {
        super("osmosis.lockup.AccountLockedLongerDurationDenomResponse", [
            { no: 1, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PeriodLock, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<AccountLockedLongerDurationDenomResponse>): AccountLockedLongerDurationDenomResponse {
        const message = { locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountLockedLongerDurationDenomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountLockedLongerDurationDenomResponse): AccountLockedLongerDurationDenomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.lockup.PeriodLock locks */ 1:
                    message.locks.push(PeriodLock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountLockedLongerDurationDenomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.lockup.PeriodLock locks = 1; */
        for (let i = 0; i < message.locks.length; i++)
            PeriodLock.internalBinaryWrite(message.locks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.lockup.AccountLockedLongerDurationDenomResponse
 */
export const AccountLockedLongerDurationDenomResponse = new AccountLockedLongerDurationDenomResponse$Type();
/**
 * @generated ServiceType for protobuf service osmosis.lockup.Query
 */
export const Query = new ServiceType("osmosis.lockup.Query", [
    { name: "ModuleBalance", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/module_balance" } }, I: ModuleBalanceRequest, O: ModuleBalanceResponse },
    { name: "ModuleLockedAmount", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/module_locked_amount" } }, I: ModuleLockedAmountRequest, O: ModuleLockedAmountResponse },
    { name: "AccountUnlockableCoins", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_unlockable_coins/{owner}" } }, I: AccountUnlockableCoinsRequest, O: AccountUnlockableCoinsResponse },
    { name: "AccountUnlockingCoins", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_unlocking_coins/{owner}" } }, I: AccountUnlockingCoinsRequest, O: AccountUnlockingCoinsResponse },
    { name: "AccountLockedCoins", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_coins/{owner}" } }, I: AccountLockedCoinsRequest, O: AccountLockedCoinsResponse },
    { name: "AccountLockedPastTime", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_pasttime/{owner}" } }, I: AccountLockedPastTimeRequest, O: AccountLockedPastTimeResponse },
    { name: "AccountLockedPastTimeNotUnlockingOnly", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_pasttime_not_unlocking_only/{owner}" } }, I: AccountLockedPastTimeNotUnlockingOnlyRequest, O: AccountLockedPastTimeNotUnlockingOnlyResponse },
    { name: "AccountUnlockedBeforeTime", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_unlocked_before_time/{owner}" } }, I: AccountUnlockedBeforeTimeRequest, O: AccountUnlockedBeforeTimeResponse },
    { name: "AccountLockedPastTimeDenom", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_pasttime_denom/{owner}" } }, I: AccountLockedPastTimeDenomRequest, O: AccountLockedPastTimeDenomResponse },
    { name: "LockedDenom", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/locked_denom" } }, I: LockedDenomRequest, O: LockedDenomResponse },
    { name: "LockedByID", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/locked_by_id/{lock_id}" } }, I: LockedRequest, O: LockedResponse },
    { name: "SyntheticLockupsByLockupID", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/synthetic_lockups_by_lock_id/{lock_id}" } }, I: SyntheticLockupsByLockupIDRequest, O: SyntheticLockupsByLockupIDResponse },
    { name: "AccountLockedLongerDuration", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_longer_duration/{owner}" } }, I: AccountLockedLongerDurationRequest, O: AccountLockedLongerDurationResponse },
    { name: "AccountLockedLongerDurationNotUnlockingOnly", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_longer_duration_not_unlocking_only/{owner}" } }, I: AccountLockedLongerDurationNotUnlockingOnlyRequest, O: AccountLockedLongerDurationNotUnlockingOnlyResponse },
    { name: "AccountLockedLongerDurationDenom", options: { "google.api.http": { get: "/osmosis/lockup/v1beta1/account_locked_longer_duration_denom/{owner}" } }, I: AccountLockedLongerDurationDenomRequest, O: AccountLockedLongerDurationDenomResponse }
]);
