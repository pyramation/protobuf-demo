// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/superfluid/tx.proto" (package "osmosis.superfluid", syntax proto3),// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Msg } from "./tx";
import type { MsgLockAndSuperfluidDelegateResponse } from "./tx";
import type { MsgLockAndSuperfluidDelegate } from "./tx";
import type { MsgSuperfluidUnbondLockResponse } from "./tx";
import type { MsgSuperfluidUnbondLock } from "./tx";
import type { MsgSuperfluidUndelegateResponse } from "./tx";
import type { MsgSuperfluidUndelegate } from "./tx";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { MsgSuperfluidDelegateResponse } from "./tx";
import type { MsgSuperfluidDelegate } from "./tx";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Msg defines the Msg service.
 *
 * @generated from protobuf service osmosis.superfluid.Msg
 */
export interface IMsgClient {
    /**
     * Execute superfluid delegation for a lockup
     *
     * @generated from protobuf rpc: SuperfluidDelegate(osmosis.superfluid.MsgSuperfluidDelegate) returns (osmosis.superfluid.MsgSuperfluidDelegateResponse);
     */
    superfluidDelegate(input: MsgSuperfluidDelegate, options?: RpcOptions): UnaryCall<MsgSuperfluidDelegate, MsgSuperfluidDelegateResponse>;
    /**
     * Execute superfluid undelegation for a lockup
     *
     * Execute superfluid redelegation for a lockup
     * rpc SuperfluidRedelegate(MsgSuperfluidRedelegate) returns
     * (MsgSuperfluidRedelegateResponse);
     *
     * @generated from protobuf rpc: SuperfluidUndelegate(osmosis.superfluid.MsgSuperfluidUndelegate) returns (osmosis.superfluid.MsgSuperfluidUndelegateResponse);
     */
    superfluidUndelegate(input: MsgSuperfluidUndelegate, options?: RpcOptions): UnaryCall<MsgSuperfluidUndelegate, MsgSuperfluidUndelegateResponse>;
    /**
     * For a given lock that is being superfluidly undelegated,
     * also unbond the underlying lock.
     *
     * @generated from protobuf rpc: SuperfluidUnbondLock(osmosis.superfluid.MsgSuperfluidUnbondLock) returns (osmosis.superfluid.MsgSuperfluidUnbondLockResponse);
     */
    superfluidUnbondLock(input: MsgSuperfluidUnbondLock, options?: RpcOptions): UnaryCall<MsgSuperfluidUnbondLock, MsgSuperfluidUnbondLockResponse>;
    /**
     * Execute lockup lock and superfluid delegation in a single msg
     *
     * @generated from protobuf rpc: LockAndSuperfluidDelegate(osmosis.superfluid.MsgLockAndSuperfluidDelegate) returns (osmosis.superfluid.MsgLockAndSuperfluidDelegateResponse);
     */
    lockAndSuperfluidDelegate(input: MsgLockAndSuperfluidDelegate, options?: RpcOptions): UnaryCall<MsgLockAndSuperfluidDelegate, MsgLockAndSuperfluidDelegateResponse>;
}
/**
 * Msg defines the Msg service.
 *
 * @generated from protobuf service osmosis.superfluid.Msg
 */
export class MsgClient implements IMsgClient, ServiceInfo {
    typeName = Msg.typeName;
    methods = Msg.methods;
    options = Msg.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Execute superfluid delegation for a lockup
     *
     * @generated from protobuf rpc: SuperfluidDelegate(osmosis.superfluid.MsgSuperfluidDelegate) returns (osmosis.superfluid.MsgSuperfluidDelegateResponse);
     */
    superfluidDelegate(input: MsgSuperfluidDelegate, options?: RpcOptions): UnaryCall<MsgSuperfluidDelegate, MsgSuperfluidDelegateResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgSuperfluidDelegate, MsgSuperfluidDelegateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Execute superfluid undelegation for a lockup
     *
     * Execute superfluid redelegation for a lockup
     * rpc SuperfluidRedelegate(MsgSuperfluidRedelegate) returns
     * (MsgSuperfluidRedelegateResponse);
     *
     * @generated from protobuf rpc: SuperfluidUndelegate(osmosis.superfluid.MsgSuperfluidUndelegate) returns (osmosis.superfluid.MsgSuperfluidUndelegateResponse);
     */
    superfluidUndelegate(input: MsgSuperfluidUndelegate, options?: RpcOptions): UnaryCall<MsgSuperfluidUndelegate, MsgSuperfluidUndelegateResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgSuperfluidUndelegate, MsgSuperfluidUndelegateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * For a given lock that is being superfluidly undelegated,
     * also unbond the underlying lock.
     *
     * @generated from protobuf rpc: SuperfluidUnbondLock(osmosis.superfluid.MsgSuperfluidUnbondLock) returns (osmosis.superfluid.MsgSuperfluidUnbondLockResponse);
     */
    superfluidUnbondLock(input: MsgSuperfluidUnbondLock, options?: RpcOptions): UnaryCall<MsgSuperfluidUnbondLock, MsgSuperfluidUnbondLockResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgSuperfluidUnbondLock, MsgSuperfluidUnbondLockResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Execute lockup lock and superfluid delegation in a single msg
     *
     * @generated from protobuf rpc: LockAndSuperfluidDelegate(osmosis.superfluid.MsgLockAndSuperfluidDelegate) returns (osmosis.superfluid.MsgLockAndSuperfluidDelegateResponse);
     */
    lockAndSuperfluidDelegate(input: MsgLockAndSuperfluidDelegate, options?: RpcOptions): UnaryCall<MsgLockAndSuperfluidDelegate, MsgLockAndSuperfluidDelegateResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<MsgLockAndSuperfluidDelegate, MsgLockAndSuperfluidDelegateResponse>("unary", this._transport, method, opt, input);
    }
}
