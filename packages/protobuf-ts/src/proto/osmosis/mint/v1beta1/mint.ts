// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/mint/v1beta1/mint.proto" (package "osmosis.mint.v1beta1", syntax proto3),// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Minter represents the minting state.
 *
 * @generated from protobuf message osmosis.mint.v1beta1.Minter
 */
export interface Minter {
    /**
     * current epoch provisions
     *
     * @generated from protobuf field: string epoch_provisions = 1;
     */
    epochProvisions: string;
}
/**
 * @generated from protobuf message osmosis.mint.v1beta1.WeightedAddress
 */
export interface WeightedAddress {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: string weight = 2;
     */
    weight: string;
}
/**
 * @generated from protobuf message osmosis.mint.v1beta1.DistributionProportions
 */
export interface DistributionProportions {
    /**
     * staking defines the proportion of the minted minted_denom that is to be
     * allocated as staking rewards.
     *
     * @generated from protobuf field: string staking = 1;
     */
    staking: string;
    /**
     * pool_incentives defines the proportion of the minted minted_denom that is
     * to be allocated as pool incentives.
     *
     * @generated from protobuf field: string pool_incentives = 2;
     */
    poolIncentives: string;
    /**
     * developer_rewards defines the proportion of the minted minted_denom that is
     * to be allocated to developer rewards address.
     *
     * @generated from protobuf field: string developer_rewards = 3;
     */
    developerRewards: string;
    /**
     * community_pool defines the proportion of the minted minted_denom that is
     * to be allocated to the community pool.
     *
     * @generated from protobuf field: string community_pool = 4;
     */
    communityPool: string;
}
/**
 * Params holds parameters for the mint module.
 *
 * @generated from protobuf message osmosis.mint.v1beta1.Params
 */
export interface Params {
    /**
     * type of coin to mint
     *
     * @generated from protobuf field: string mint_denom = 1;
     */
    mintDenom: string;
    /**
     * epoch provisions from the first epoch
     *
     * @generated from protobuf field: string genesis_epoch_provisions = 2;
     */
    genesisEpochProvisions: string;
    /**
     * mint epoch identifier
     *
     * @generated from protobuf field: string epoch_identifier = 3;
     */
    epochIdentifier: string;
    /**
     * number of epochs take to reduce rewards
     *
     * @generated from protobuf field: int64 reduction_period_in_epochs = 4;
     */
    reductionPeriodInEpochs: bigint;
    /**
     * reduction multiplier to execute on each period
     *
     * @generated from protobuf field: string reduction_factor = 5;
     */
    reductionFactor: string;
    /**
     * distribution_proportions defines the proportion of the minted denom
     *
     * @generated from protobuf field: osmosis.mint.v1beta1.DistributionProportions distribution_proportions = 6;
     */
    distributionProportions?: DistributionProportions;
    /**
     * address to receive developer rewards
     *
     * @generated from protobuf field: repeated osmosis.mint.v1beta1.WeightedAddress weighted_developer_rewards_receivers = 7;
     */
    weightedDeveloperRewardsReceivers: WeightedAddress[];
    /**
     * start epoch to distribute minting rewards
     *
     * @generated from protobuf field: int64 minting_rewards_distribution_start_epoch = 8;
     */
    mintingRewardsDistributionStartEpoch: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class Minter$Type extends MessageType<Minter> {
    constructor() {
        super("osmosis.mint.v1beta1.Minter", [
            { no: 1, name: "epoch_provisions", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"epoch_provisions\"" } }
        ]);
    }
    create(value?: PartialMessage<Minter>): Minter {
        const message = { epochProvisions: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Minter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Minter): Minter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string epoch_provisions */ 1:
                    message.epochProvisions = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Minter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string epoch_provisions = 1; */
        if (message.epochProvisions !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.epochProvisions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.mint.v1beta1.Minter
 */
export const Minter = new Minter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightedAddress$Type extends MessageType<WeightedAddress> {
    constructor() {
        super("osmosis.mint.v1beta1.WeightedAddress", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"address\"" } },
            { no: 2, name: "weight", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"weight\"" } }
        ]);
    }
    create(value?: PartialMessage<WeightedAddress>): WeightedAddress {
        const message = { address: "", weight: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeightedAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightedAddress): WeightedAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string weight */ 2:
                    message.weight = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightedAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string weight = 2; */
        if (message.weight !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.mint.v1beta1.WeightedAddress
 */
export const WeightedAddress = new WeightedAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DistributionProportions$Type extends MessageType<DistributionProportions> {
    constructor() {
        super("osmosis.mint.v1beta1.DistributionProportions", [
            { no: 1, name: "staking", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"staking\"" } },
            { no: 2, name: "pool_incentives", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"pool_incentives\"" } },
            { no: 3, name: "developer_rewards", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"developer_rewards\"" } },
            { no: 4, name: "community_pool", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"community_pool\"" } }
        ]);
    }
    create(value?: PartialMessage<DistributionProportions>): DistributionProportions {
        const message = { staking: "", poolIncentives: "", developerRewards: "", communityPool: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DistributionProportions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DistributionProportions): DistributionProportions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string staking */ 1:
                    message.staking = reader.string();
                    break;
                case /* string pool_incentives */ 2:
                    message.poolIncentives = reader.string();
                    break;
                case /* string developer_rewards */ 3:
                    message.developerRewards = reader.string();
                    break;
                case /* string community_pool */ 4:
                    message.communityPool = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DistributionProportions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string staking = 1; */
        if (message.staking !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.staking);
        /* string pool_incentives = 2; */
        if (message.poolIncentives !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.poolIncentives);
        /* string developer_rewards = 3; */
        if (message.developerRewards !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.developerRewards);
        /* string community_pool = 4; */
        if (message.communityPool !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.communityPool);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.mint.v1beta1.DistributionProportions
 */
export const DistributionProportions = new DistributionProportions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("osmosis.mint.v1beta1.Params", [
            { no: 1, name: "mint_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "genesis_epoch_provisions", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"genesis_epoch_provisions\"" } },
            { no: 3, name: "epoch_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"epoch_identifier\"" } },
            { no: 4, name: "reduction_period_in_epochs", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"reduction_period_in_epochs\"" } },
            { no: 5, name: "reduction_factor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec", "gogoproto.moretags": "yaml:\"reduction_factor\"" } },
            { no: 6, name: "distribution_proportions", kind: "message", T: () => DistributionProportions, options: { "gogoproto.nullable": false } },
            { no: 7, name: "weighted_developer_rewards_receivers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WeightedAddress, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"developer_rewards_receiver\"" } },
            { no: 8, name: "minting_rewards_distribution_start_epoch", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"minting_rewards_distribution_start_epoch\"" } }
        ], { "gogoproto.goproto_stringer": false });
    }
    create(value?: PartialMessage<Params>): Params {
        const message = { mintDenom: "", genesisEpochProvisions: "", epochIdentifier: "", reductionPeriodInEpochs: 0n, reductionFactor: "", weightedDeveloperRewardsReceivers: [], mintingRewardsDistributionStartEpoch: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint_denom */ 1:
                    message.mintDenom = reader.string();
                    break;
                case /* string genesis_epoch_provisions */ 2:
                    message.genesisEpochProvisions = reader.string();
                    break;
                case /* string epoch_identifier */ 3:
                    message.epochIdentifier = reader.string();
                    break;
                case /* int64 reduction_period_in_epochs */ 4:
                    message.reductionPeriodInEpochs = reader.int64().toBigInt();
                    break;
                case /* string reduction_factor */ 5:
                    message.reductionFactor = reader.string();
                    break;
                case /* osmosis.mint.v1beta1.DistributionProportions distribution_proportions */ 6:
                    message.distributionProportions = DistributionProportions.internalBinaryRead(reader, reader.uint32(), options, message.distributionProportions);
                    break;
                case /* repeated osmosis.mint.v1beta1.WeightedAddress weighted_developer_rewards_receivers */ 7:
                    message.weightedDeveloperRewardsReceivers.push(WeightedAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 minting_rewards_distribution_start_epoch */ 8:
                    message.mintingRewardsDistributionStartEpoch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint_denom = 1; */
        if (message.mintDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mintDenom);
        /* string genesis_epoch_provisions = 2; */
        if (message.genesisEpochProvisions !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.genesisEpochProvisions);
        /* string epoch_identifier = 3; */
        if (message.epochIdentifier !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.epochIdentifier);
        /* int64 reduction_period_in_epochs = 4; */
        if (message.reductionPeriodInEpochs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.reductionPeriodInEpochs);
        /* string reduction_factor = 5; */
        if (message.reductionFactor !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reductionFactor);
        /* osmosis.mint.v1beta1.DistributionProportions distribution_proportions = 6; */
        if (message.distributionProportions)
            DistributionProportions.internalBinaryWrite(message.distributionProportions, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated osmosis.mint.v1beta1.WeightedAddress weighted_developer_rewards_receivers = 7; */
        for (let i = 0; i < message.weightedDeveloperRewardsReceivers.length; i++)
            WeightedAddress.internalBinaryWrite(message.weightedDeveloperRewardsReceivers[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* int64 minting_rewards_distribution_start_epoch = 8; */
        if (message.mintingRewardsDistributionStartEpoch !== 0n)
            writer.tag(8, WireType.Varint).int64(message.mintingRewardsDistributionStartEpoch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.mint.v1beta1.Params
 */
export const Params = new Params$Type();
