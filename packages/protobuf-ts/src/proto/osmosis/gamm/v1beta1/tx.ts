// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/gamm/v1beta1/tx.proto" (package "osmosis.gamm.v1beta1", syntax proto3),// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
/**
 * ===================== MsgJoinPool
 * This is really MsgJoinPoolNoSwap
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinPool
 */
export interface MsgJoinPool {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string shareOutAmount = 3;
     */
    shareOutAmount: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin tokenInMaxs = 4;
     */
    tokenInMaxs: Coin[];
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinPoolResponse
 */
export interface MsgJoinPoolResponse {
}
/**
 * ===================== MsgExitPool
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitPool
 */
export interface MsgExitPool {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string shareInAmount = 3;
     */
    shareInAmount: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin tokenOutMins = 4;
     */
    tokenOutMins: Coin[];
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitPoolResponse
 */
export interface MsgExitPoolResponse {
}
/**
 * ===================== MsgSwapExactAmountIn
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.SwapAmountInRoute
 */
export interface SwapAmountInRoute {
    /**
     * @generated from protobuf field: uint64 poolId = 1;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string tokenOutDenom = 2;
     */
    tokenOutDenom: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountIn
 */
export interface MsgSwapExactAmountIn {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated osmosis.gamm.v1beta1.SwapAmountInRoute routes = 2;
     */
    routes: SwapAmountInRoute[];
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin tokenIn = 3;
     */
    tokenIn?: Coin;
    /**
     * @generated from protobuf field: string tokenOutMinAmount = 4;
     */
    tokenOutMinAmount: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountInResponse
 */
export interface MsgSwapExactAmountInResponse {
    /**
     * @generated from protobuf field: string tokenOutAmount = 1;
     */
    tokenOutAmount: string;
}
/**
 * ===================== MsgSwapExactAmountOut
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.SwapAmountOutRoute
 */
export interface SwapAmountOutRoute {
    /**
     * @generated from protobuf field: uint64 poolId = 1;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string tokenInDenom = 2;
     */
    tokenInDenom: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountOut
 */
export interface MsgSwapExactAmountOut {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated osmosis.gamm.v1beta1.SwapAmountOutRoute routes = 2;
     */
    routes: SwapAmountOutRoute[];
    /**
     * @generated from protobuf field: string tokenInMaxAmount = 3;
     */
    tokenInMaxAmount: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin tokenOut = 4;
     */
    tokenOut?: Coin;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountOutResponse
 */
export interface MsgSwapExactAmountOutResponse {
    /**
     * @generated from protobuf field: string tokenInAmount = 1;
     */
    tokenInAmount: string;
}
/**
 * ===================== MsgJoinSwapExternAmountIn
 * TODO: Rename to MsgJoinSwapExactAmountIn
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinSwapExternAmountIn
 */
export interface MsgJoinSwapExternAmountIn {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin tokenIn = 3;
     */
    tokenIn?: Coin;
    /**
     * reserved 3;
     * reserved "token_in";
     *
     * @generated from protobuf field: string shareOutMinAmount = 4;
     */
    shareOutMinAmount: string; // repeated cosmos.base.v1beta1.Coin tokensIn = 5 [
    //   (gogoproto.moretags) = "yaml:\"tokens_in\"",
    //   (gogoproto.nullable) = false
    // ];
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinSwapExternAmountInResponse
 */
export interface MsgJoinSwapExternAmountInResponse {
    /**
     * @generated from protobuf field: string shareOutAmount = 1;
     */
    shareOutAmount: string;
}
/**
 * ===================== MsgJoinSwapShareAmountOut
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOut
 */
export interface MsgJoinSwapShareAmountOut {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string tokenInDenom = 3;
     */
    tokenInDenom: string;
    /**
     * @generated from protobuf field: string shareOutAmount = 4;
     */
    shareOutAmount: string;
    /**
     * @generated from protobuf field: string tokenInMaxAmount = 5;
     */
    tokenInMaxAmount: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOutResponse
 */
export interface MsgJoinSwapShareAmountOutResponse {
    /**
     * @generated from protobuf field: string tokenInAmount = 1;
     */
    tokenInAmount: string;
}
/**
 * ===================== MsgExitSwapShareAmountIn
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitSwapShareAmountIn
 */
export interface MsgExitSwapShareAmountIn {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: string tokenOutDenom = 3;
     */
    tokenOutDenom: string;
    /**
     * @generated from protobuf field: string shareInAmount = 4;
     */
    shareInAmount: string;
    /**
     * @generated from protobuf field: string tokenOutMinAmount = 5;
     */
    tokenOutMinAmount: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitSwapShareAmountInResponse
 */
export interface MsgExitSwapShareAmountInResponse {
    /**
     * @generated from protobuf field: string tokenOutAmount = 1;
     */
    tokenOutAmount: string;
}
/**
 * ===================== MsgExitSwapExternAmountOut
 *
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitSwapExternAmountOut
 */
export interface MsgExitSwapExternAmountOut {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: uint64 poolId = 2;
     */
    poolId: bigint;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin tokenOut = 3;
     */
    tokenOut?: Coin;
    /**
     * @generated from protobuf field: string shareInMaxAmount = 4;
     */
    shareInMaxAmount: string;
}
/**
 * @generated from protobuf message osmosis.gamm.v1beta1.MsgExitSwapExternAmountOutResponse
 */
export interface MsgExitSwapExternAmountOutResponse {
    /**
     * @generated from protobuf field: string shareInAmount = 1;
     */
    shareInAmount: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinPool$Type extends MessageType<MsgJoinPool> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinPool", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "shareOutAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"pool_amount_out\"" } },
            { no: 4, name: "tokenInMaxs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_in_max_amounts\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgJoinPool>): MsgJoinPool {
        const message = { sender: "", poolId: 0n, shareOutAmount: "", tokenInMaxs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinPool): MsgJoinPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string shareOutAmount */ 3:
                    message.shareOutAmount = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin tokenInMaxs */ 4:
                    message.tokenInMaxs.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgJoinPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* string shareOutAmount = 3; */
        if (message.shareOutAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shareOutAmount);
        /* repeated cosmos.base.v1beta1.Coin tokenInMaxs = 4; */
        for (let i = 0; i < message.tokenInMaxs.length; i++)
            Coin.internalBinaryWrite(message.tokenInMaxs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinPool
 */
export const MsgJoinPool = new MsgJoinPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinPoolResponse$Type extends MessageType<MsgJoinPoolResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinPoolResponse", []);
    }
    create(value?: PartialMessage<MsgJoinPoolResponse>): MsgJoinPoolResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinPoolResponse): MsgJoinPoolResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgJoinPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinPoolResponse
 */
export const MsgJoinPoolResponse = new MsgJoinPoolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitPool$Type extends MessageType<MsgExitPool> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitPool", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "shareInAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_in_amount\"" } },
            { no: 4, name: "tokenOutMins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_out_min_amounts\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgExitPool>): MsgExitPool {
        const message = { sender: "", poolId: 0n, shareInAmount: "", tokenOutMins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitPool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitPool): MsgExitPool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string shareInAmount */ 3:
                    message.shareInAmount = reader.string();
                    break;
                case /* repeated cosmos.base.v1beta1.Coin tokenOutMins */ 4:
                    message.tokenOutMins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExitPool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* string shareInAmount = 3; */
        if (message.shareInAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shareInAmount);
        /* repeated cosmos.base.v1beta1.Coin tokenOutMins = 4; */
        for (let i = 0; i < message.tokenOutMins.length; i++)
            Coin.internalBinaryWrite(message.tokenOutMins[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitPool
 */
export const MsgExitPool = new MsgExitPool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitPoolResponse$Type extends MessageType<MsgExitPoolResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitPoolResponse", []);
    }
    create(value?: PartialMessage<MsgExitPoolResponse>): MsgExitPoolResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitPoolResponse): MsgExitPoolResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgExitPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitPoolResponse
 */
export const MsgExitPoolResponse = new MsgExitPoolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapAmountInRoute$Type extends MessageType<SwapAmountInRoute> {
    constructor() {
        super("osmosis.gamm.v1beta1.SwapAmountInRoute", [
            { no: 1, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 2, name: "tokenOutDenom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"token_out_denom\"" } }
        ]);
    }
    create(value?: PartialMessage<SwapAmountInRoute>): SwapAmountInRoute {
        const message = { poolId: 0n, tokenOutDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapAmountInRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapAmountInRoute): SwapAmountInRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 poolId */ 1:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string tokenOutDenom */ 2:
                    message.tokenOutDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapAmountInRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 poolId = 1; */
        if (message.poolId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.poolId);
        /* string tokenOutDenom = 2; */
        if (message.tokenOutDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenOutDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.SwapAmountInRoute
 */
export const SwapAmountInRoute = new SwapAmountInRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSwapExactAmountIn$Type extends MessageType<MsgSwapExactAmountIn> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgSwapExactAmountIn", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SwapAmountInRoute, options: { "gogoproto.nullable": false } },
            { no: 3, name: "tokenIn", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_in\"" } },
            { no: 4, name: "tokenOutMinAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_out_min_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgSwapExactAmountIn>): MsgSwapExactAmountIn {
        const message = { sender: "", routes: [], tokenOutMinAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSwapExactAmountIn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSwapExactAmountIn): MsgSwapExactAmountIn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated osmosis.gamm.v1beta1.SwapAmountInRoute routes */ 2:
                    message.routes.push(SwapAmountInRoute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.v1beta1.Coin tokenIn */ 3:
                    message.tokenIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.tokenIn);
                    break;
                case /* string tokenOutMinAmount */ 4:
                    message.tokenOutMinAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSwapExactAmountIn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated osmosis.gamm.v1beta1.SwapAmountInRoute routes = 2; */
        for (let i = 0; i < message.routes.length; i++)
            SwapAmountInRoute.internalBinaryWrite(message.routes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin tokenIn = 3; */
        if (message.tokenIn)
            Coin.internalBinaryWrite(message.tokenIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string tokenOutMinAmount = 4; */
        if (message.tokenOutMinAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tokenOutMinAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountIn
 */
export const MsgSwapExactAmountIn = new MsgSwapExactAmountIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSwapExactAmountInResponse$Type extends MessageType<MsgSwapExactAmountInResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgSwapExactAmountInResponse", [
            { no: 1, name: "tokenOutAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_out_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgSwapExactAmountInResponse>): MsgSwapExactAmountInResponse {
        const message = { tokenOutAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSwapExactAmountInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSwapExactAmountInResponse): MsgSwapExactAmountInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tokenOutAmount */ 1:
                    message.tokenOutAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSwapExactAmountInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tokenOutAmount = 1; */
        if (message.tokenOutAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenOutAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountInResponse
 */
export const MsgSwapExactAmountInResponse = new MsgSwapExactAmountInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapAmountOutRoute$Type extends MessageType<SwapAmountOutRoute> {
    constructor() {
        super("osmosis.gamm.v1beta1.SwapAmountOutRoute", [
            { no: 1, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 2, name: "tokenInDenom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"token_out_denom\"" } }
        ]);
    }
    create(value?: PartialMessage<SwapAmountOutRoute>): SwapAmountOutRoute {
        const message = { poolId: 0n, tokenInDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapAmountOutRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapAmountOutRoute): SwapAmountOutRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 poolId */ 1:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string tokenInDenom */ 2:
                    message.tokenInDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapAmountOutRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 poolId = 1; */
        if (message.poolId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.poolId);
        /* string tokenInDenom = 2; */
        if (message.tokenInDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenInDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.SwapAmountOutRoute
 */
export const SwapAmountOutRoute = new SwapAmountOutRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSwapExactAmountOut$Type extends MessageType<MsgSwapExactAmountOut> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgSwapExactAmountOut", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SwapAmountOutRoute, options: { "gogoproto.nullable": false } },
            { no: 3, name: "tokenInMaxAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_in_max_amount\"" } },
            { no: 4, name: "tokenOut", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_out\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgSwapExactAmountOut>): MsgSwapExactAmountOut {
        const message = { sender: "", routes: [], tokenInMaxAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSwapExactAmountOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSwapExactAmountOut): MsgSwapExactAmountOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated osmosis.gamm.v1beta1.SwapAmountOutRoute routes */ 2:
                    message.routes.push(SwapAmountOutRoute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string tokenInMaxAmount */ 3:
                    message.tokenInMaxAmount = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin tokenOut */ 4:
                    message.tokenOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.tokenOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSwapExactAmountOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated osmosis.gamm.v1beta1.SwapAmountOutRoute routes = 2; */
        for (let i = 0; i < message.routes.length; i++)
            SwapAmountOutRoute.internalBinaryWrite(message.routes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string tokenInMaxAmount = 3; */
        if (message.tokenInMaxAmount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenInMaxAmount);
        /* cosmos.base.v1beta1.Coin tokenOut = 4; */
        if (message.tokenOut)
            Coin.internalBinaryWrite(message.tokenOut, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountOut
 */
export const MsgSwapExactAmountOut = new MsgSwapExactAmountOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSwapExactAmountOutResponse$Type extends MessageType<MsgSwapExactAmountOutResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgSwapExactAmountOutResponse", [
            { no: 1, name: "tokenInAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_in_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgSwapExactAmountOutResponse>): MsgSwapExactAmountOutResponse {
        const message = { tokenInAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSwapExactAmountOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSwapExactAmountOutResponse): MsgSwapExactAmountOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tokenInAmount */ 1:
                    message.tokenInAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSwapExactAmountOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tokenInAmount = 1; */
        if (message.tokenInAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenInAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgSwapExactAmountOutResponse
 */
export const MsgSwapExactAmountOutResponse = new MsgSwapExactAmountOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinSwapExternAmountIn$Type extends MessageType<MsgJoinSwapExternAmountIn> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinSwapExternAmountIn", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "tokenIn", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_in\"" } },
            { no: 4, name: "shareOutMinAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_out_min_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgJoinSwapExternAmountIn>): MsgJoinSwapExternAmountIn {
        const message = { sender: "", poolId: 0n, shareOutMinAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinSwapExternAmountIn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinSwapExternAmountIn): MsgJoinSwapExternAmountIn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* cosmos.base.v1beta1.Coin tokenIn */ 3:
                    message.tokenIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.tokenIn);
                    break;
                case /* string shareOutMinAmount */ 4:
                    message.shareOutMinAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgJoinSwapExternAmountIn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* cosmos.base.v1beta1.Coin tokenIn = 3; */
        if (message.tokenIn)
            Coin.internalBinaryWrite(message.tokenIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string shareOutMinAmount = 4; */
        if (message.shareOutMinAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shareOutMinAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinSwapExternAmountIn
 */
export const MsgJoinSwapExternAmountIn = new MsgJoinSwapExternAmountIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinSwapExternAmountInResponse$Type extends MessageType<MsgJoinSwapExternAmountInResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinSwapExternAmountInResponse", [
            { no: 1, name: "shareOutAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_out_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgJoinSwapExternAmountInResponse>): MsgJoinSwapExternAmountInResponse {
        const message = { shareOutAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinSwapExternAmountInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinSwapExternAmountInResponse): MsgJoinSwapExternAmountInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shareOutAmount */ 1:
                    message.shareOutAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgJoinSwapExternAmountInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shareOutAmount = 1; */
        if (message.shareOutAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shareOutAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinSwapExternAmountInResponse
 */
export const MsgJoinSwapExternAmountInResponse = new MsgJoinSwapExternAmountInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinSwapShareAmountOut$Type extends MessageType<MsgJoinSwapShareAmountOut> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOut", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "tokenInDenom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"token_in_denom\"" } },
            { no: 4, name: "shareOutAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_out_amount\"" } },
            { no: 5, name: "tokenInMaxAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_in_max_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgJoinSwapShareAmountOut>): MsgJoinSwapShareAmountOut {
        const message = { sender: "", poolId: 0n, tokenInDenom: "", shareOutAmount: "", tokenInMaxAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinSwapShareAmountOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinSwapShareAmountOut): MsgJoinSwapShareAmountOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string tokenInDenom */ 3:
                    message.tokenInDenom = reader.string();
                    break;
                case /* string shareOutAmount */ 4:
                    message.shareOutAmount = reader.string();
                    break;
                case /* string tokenInMaxAmount */ 5:
                    message.tokenInMaxAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgJoinSwapShareAmountOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* string tokenInDenom = 3; */
        if (message.tokenInDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenInDenom);
        /* string shareOutAmount = 4; */
        if (message.shareOutAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shareOutAmount);
        /* string tokenInMaxAmount = 5; */
        if (message.tokenInMaxAmount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenInMaxAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOut
 */
export const MsgJoinSwapShareAmountOut = new MsgJoinSwapShareAmountOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgJoinSwapShareAmountOutResponse$Type extends MessageType<MsgJoinSwapShareAmountOutResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOutResponse", [
            { no: 1, name: "tokenInAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_in_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgJoinSwapShareAmountOutResponse>): MsgJoinSwapShareAmountOutResponse {
        const message = { tokenInAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgJoinSwapShareAmountOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgJoinSwapShareAmountOutResponse): MsgJoinSwapShareAmountOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tokenInAmount */ 1:
                    message.tokenInAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgJoinSwapShareAmountOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tokenInAmount = 1; */
        if (message.tokenInAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenInAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgJoinSwapShareAmountOutResponse
 */
export const MsgJoinSwapShareAmountOutResponse = new MsgJoinSwapShareAmountOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitSwapShareAmountIn$Type extends MessageType<MsgExitSwapShareAmountIn> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitSwapShareAmountIn", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "tokenOutDenom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"token_out_denom\"" } },
            { no: 4, name: "shareInAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_in_amount\"" } },
            { no: 5, name: "tokenOutMinAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_out_min_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgExitSwapShareAmountIn>): MsgExitSwapShareAmountIn {
        const message = { sender: "", poolId: 0n, tokenOutDenom: "", shareInAmount: "", tokenOutMinAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitSwapShareAmountIn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitSwapShareAmountIn): MsgExitSwapShareAmountIn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* string tokenOutDenom */ 3:
                    message.tokenOutDenom = reader.string();
                    break;
                case /* string shareInAmount */ 4:
                    message.shareInAmount = reader.string();
                    break;
                case /* string tokenOutMinAmount */ 5:
                    message.tokenOutMinAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExitSwapShareAmountIn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* string tokenOutDenom = 3; */
        if (message.tokenOutDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tokenOutDenom);
        /* string shareInAmount = 4; */
        if (message.shareInAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shareInAmount);
        /* string tokenOutMinAmount = 5; */
        if (message.tokenOutMinAmount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenOutMinAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitSwapShareAmountIn
 */
export const MsgExitSwapShareAmountIn = new MsgExitSwapShareAmountIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitSwapShareAmountInResponse$Type extends MessageType<MsgExitSwapShareAmountInResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitSwapShareAmountInResponse", [
            { no: 1, name: "tokenOutAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"token_out_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgExitSwapShareAmountInResponse>): MsgExitSwapShareAmountInResponse {
        const message = { tokenOutAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitSwapShareAmountInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitSwapShareAmountInResponse): MsgExitSwapShareAmountInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tokenOutAmount */ 1:
                    message.tokenOutAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExitSwapShareAmountInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tokenOutAmount = 1; */
        if (message.tokenOutAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenOutAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitSwapShareAmountInResponse
 */
export const MsgExitSwapShareAmountInResponse = new MsgExitSwapShareAmountInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitSwapExternAmountOut$Type extends MessageType<MsgExitSwapExternAmountOut> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitSwapExternAmountOut", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "poolId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "gogoproto.moretags": "yaml:\"pool_id\"" } },
            { no: 3, name: "tokenOut", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"token_out\"" } },
            { no: 4, name: "shareInMaxAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_in_max_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgExitSwapExternAmountOut>): MsgExitSwapExternAmountOut {
        const message = { sender: "", poolId: 0n, shareInMaxAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitSwapExternAmountOut>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitSwapExternAmountOut): MsgExitSwapExternAmountOut {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* uint64 poolId */ 2:
                    message.poolId = reader.uint64().toBigInt();
                    break;
                case /* cosmos.base.v1beta1.Coin tokenOut */ 3:
                    message.tokenOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.tokenOut);
                    break;
                case /* string shareInMaxAmount */ 4:
                    message.shareInMaxAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExitSwapExternAmountOut, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* uint64 poolId = 2; */
        if (message.poolId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.poolId);
        /* cosmos.base.v1beta1.Coin tokenOut = 3; */
        if (message.tokenOut)
            Coin.internalBinaryWrite(message.tokenOut, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string shareInMaxAmount = 4; */
        if (message.shareInMaxAmount !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shareInMaxAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitSwapExternAmountOut
 */
export const MsgExitSwapExternAmountOut = new MsgExitSwapExternAmountOut$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExitSwapExternAmountOutResponse$Type extends MessageType<MsgExitSwapExternAmountOutResponse> {
    constructor() {
        super("osmosis.gamm.v1beta1.MsgExitSwapExternAmountOutResponse", [
            { no: 1, name: "shareInAmount", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"share_in_amount\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgExitSwapExternAmountOutResponse>): MsgExitSwapExternAmountOutResponse {
        const message = { shareInAmount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExitSwapExternAmountOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExitSwapExternAmountOutResponse): MsgExitSwapExternAmountOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shareInAmount */ 1:
                    message.shareInAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExitSwapExternAmountOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shareInAmount = 1; */
        if (message.shareInAmount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shareInAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.gamm.v1beta1.MsgExitSwapExternAmountOutResponse
 */
export const MsgExitSwapExternAmountOutResponse = new MsgExitSwapExternAmountOutResponse$Type();
/**
 * @generated ServiceType for protobuf service osmosis.gamm.v1beta1.Msg
 */
export const Msg = new ServiceType("osmosis.gamm.v1beta1.Msg", [
    { name: "JoinPool", options: {}, I: MsgJoinPool, O: MsgJoinPoolResponse },
    { name: "ExitPool", options: {}, I: MsgExitPool, O: MsgExitPoolResponse },
    { name: "SwapExactAmountIn", options: {}, I: MsgSwapExactAmountIn, O: MsgSwapExactAmountInResponse },
    { name: "SwapExactAmountOut", options: {}, I: MsgSwapExactAmountOut, O: MsgSwapExactAmountOutResponse },
    { name: "JoinSwapExternAmountIn", options: {}, I: MsgJoinSwapExternAmountIn, O: MsgJoinSwapExternAmountInResponse },
    { name: "JoinSwapShareAmountOut", options: {}, I: MsgJoinSwapShareAmountOut, O: MsgJoinSwapShareAmountOutResponse },
    { name: "ExitSwapExternAmountOut", options: {}, I: MsgExitSwapExternAmountOut, O: MsgExitSwapExternAmountOutResponse },
    { name: "ExitSwapShareAmountIn", options: {}, I: MsgExitSwapShareAmountIn, O: MsgExitSwapShareAmountInResponse }
]);
