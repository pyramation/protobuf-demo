// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/incentives/query.proto" (package "osmosis.incentives", syntax proto3),// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../google/protobuf/duration";
import { PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import { PageRequest } from "../../cosmos/base/query/v1beta1/pagination";
import { Gauge } from "./gauge";
import { Coin } from "../../cosmos/base/v1beta1/coin";
/**
 * @generated from protobuf message osmosis.incentives.ModuleToDistributeCoinsRequest
 */
export interface ModuleToDistributeCoinsRequest {
}
/**
 * @generated from protobuf message osmosis.incentives.ModuleToDistributeCoinsResponse
 */
export interface ModuleToDistributeCoinsResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.incentives.ModuleDistributedCoinsRequest
 */
export interface ModuleDistributedCoinsRequest {
}
/**
 * @generated from protobuf message osmosis.incentives.ModuleDistributedCoinsResponse
 */
export interface ModuleDistributedCoinsResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.incentives.GaugeByIDRequest
 */
export interface GaugeByIDRequest {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message osmosis.incentives.GaugeByIDResponse
 */
export interface GaugeByIDResponse {
    /**
     * @generated from protobuf field: osmosis.incentives.Gauge gauge = 1;
     */
    gauge?: Gauge;
}
/**
 * @generated from protobuf message osmosis.incentives.GaugesRequest
 */
export interface GaugesRequest {
    /**
     * pagination defines an pagination for the request.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
     */
    pagination?: PageRequest;
}
/**
 * @generated from protobuf message osmosis.incentives.GaugesResponse
 */
export interface GaugesResponse {
    /**
     * @generated from protobuf field: repeated osmosis.incentives.Gauge data = 1;
     */
    data: Gauge[];
    /**
     * pagination defines an pagination for the response.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
}
/**
 * @generated from protobuf message osmosis.incentives.ActiveGaugesRequest
 */
export interface ActiveGaugesRequest {
    /**
     * pagination defines an pagination for the request.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
     */
    pagination?: PageRequest;
}
/**
 * @generated from protobuf message osmosis.incentives.ActiveGaugesResponse
 */
export interface ActiveGaugesResponse {
    /**
     * @generated from protobuf field: repeated osmosis.incentives.Gauge data = 1;
     */
    data: Gauge[];
    /**
     * pagination defines an pagination for the response.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
}
/**
 * @generated from protobuf message osmosis.incentives.ActiveGaugesPerDenomRequest
 */
export interface ActiveGaugesPerDenomRequest {
    /**
     * @generated from protobuf field: string denom = 1;
     */
    denom: string;
    /**
     * pagination defines an pagination for the request.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
     */
    pagination?: PageRequest;
}
/**
 * @generated from protobuf message osmosis.incentives.ActiveGaugesPerDenomResponse
 */
export interface ActiveGaugesPerDenomResponse {
    /**
     * @generated from protobuf field: repeated osmosis.incentives.Gauge data = 1;
     */
    data: Gauge[];
    /**
     * pagination defines an pagination for the response.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
}
/**
 * @generated from protobuf message osmosis.incentives.UpcomingGaugesRequest
 */
export interface UpcomingGaugesRequest {
    /**
     * pagination defines an pagination for the request.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
     */
    pagination?: PageRequest;
}
/**
 * @generated from protobuf message osmosis.incentives.UpcomingGaugesResponse
 */
export interface UpcomingGaugesResponse {
    /**
     * @generated from protobuf field: repeated osmosis.incentives.Gauge data = 1;
     */
    data: Gauge[];
    /**
     * pagination defines an pagination for the response.
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
}
/**
 * @generated from protobuf message osmosis.incentives.RewardsEstRequest
 */
export interface RewardsEstRequest {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: repeated uint64 lock_ids = 2;
     */
    lockIds: bigint[];
    /**
     * @generated from protobuf field: int64 end_epoch = 3;
     */
    endEpoch: bigint;
}
/**
 * @generated from protobuf message osmosis.incentives.RewardsEstResponse
 */
export interface RewardsEstResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.incentives.QueryLockableDurationsRequest
 */
export interface QueryLockableDurationsRequest {
}
/**
 * @generated from protobuf message osmosis.incentives.QueryLockableDurationsResponse
 */
export interface QueryLockableDurationsResponse {
    /**
     * @generated from protobuf field: repeated google.protobuf.Duration lockable_durations = 1;
     */
    lockableDurations: Duration[];
}
// @generated message type with reflection information, may provide speed optimized methods
class ModuleToDistributeCoinsRequest$Type extends MessageType<ModuleToDistributeCoinsRequest> {
    constructor() {
        super("osmosis.incentives.ModuleToDistributeCoinsRequest", []);
    }
    create(value?: PartialMessage<ModuleToDistributeCoinsRequest>): ModuleToDistributeCoinsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleToDistributeCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleToDistributeCoinsRequest): ModuleToDistributeCoinsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ModuleToDistributeCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ModuleToDistributeCoinsRequest
 */
export const ModuleToDistributeCoinsRequest = new ModuleToDistributeCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleToDistributeCoinsResponse$Type extends MessageType<ModuleToDistributeCoinsResponse> {
    constructor() {
        super("osmosis.incentives.ModuleToDistributeCoinsResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<ModuleToDistributeCoinsResponse>): ModuleToDistributeCoinsResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleToDistributeCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleToDistributeCoinsResponse): ModuleToDistributeCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleToDistributeCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ModuleToDistributeCoinsResponse
 */
export const ModuleToDistributeCoinsResponse = new ModuleToDistributeCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleDistributedCoinsRequest$Type extends MessageType<ModuleDistributedCoinsRequest> {
    constructor() {
        super("osmosis.incentives.ModuleDistributedCoinsRequest", []);
    }
    create(value?: PartialMessage<ModuleDistributedCoinsRequest>): ModuleDistributedCoinsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleDistributedCoinsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleDistributedCoinsRequest): ModuleDistributedCoinsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ModuleDistributedCoinsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ModuleDistributedCoinsRequest
 */
export const ModuleDistributedCoinsRequest = new ModuleDistributedCoinsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleDistributedCoinsResponse$Type extends MessageType<ModuleDistributedCoinsResponse> {
    constructor() {
        super("osmosis.incentives.ModuleDistributedCoinsResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<ModuleDistributedCoinsResponse>): ModuleDistributedCoinsResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleDistributedCoinsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleDistributedCoinsResponse): ModuleDistributedCoinsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleDistributedCoinsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ModuleDistributedCoinsResponse
 */
export const ModuleDistributedCoinsResponse = new ModuleDistributedCoinsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GaugeByIDRequest$Type extends MessageType<GaugeByIDRequest> {
    constructor() {
        super("osmosis.incentives.GaugeByIDRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GaugeByIDRequest>): GaugeByIDRequest {
        const message = { id: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GaugeByIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GaugeByIDRequest): GaugeByIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GaugeByIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.GaugeByIDRequest
 */
export const GaugeByIDRequest = new GaugeByIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GaugeByIDResponse$Type extends MessageType<GaugeByIDResponse> {
    constructor() {
        super("osmosis.incentives.GaugeByIDResponse", [
            { no: 1, name: "gauge", kind: "message", T: () => Gauge }
        ]);
    }
    create(value?: PartialMessage<GaugeByIDResponse>): GaugeByIDResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GaugeByIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GaugeByIDResponse): GaugeByIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* osmosis.incentives.Gauge gauge */ 1:
                    message.gauge = Gauge.internalBinaryRead(reader, reader.uint32(), options, message.gauge);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GaugeByIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* osmosis.incentives.Gauge gauge = 1; */
        if (message.gauge)
            Gauge.internalBinaryWrite(message.gauge, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.GaugeByIDResponse
 */
export const GaugeByIDResponse = new GaugeByIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GaugesRequest$Type extends MessageType<GaugesRequest> {
    constructor() {
        super("osmosis.incentives.GaugesRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<GaugesRequest>): GaugesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GaugesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GaugesRequest): GaugesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GaugesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.GaugesRequest
 */
export const GaugesRequest = new GaugesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GaugesResponse$Type extends MessageType<GaugesResponse> {
    constructor() {
        super("osmosis.incentives.GaugesResponse", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gauge, options: { "gogoproto.nullable": false } },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
        ]);
    }
    create(value?: PartialMessage<GaugesResponse>): GaugesResponse {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GaugesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GaugesResponse): GaugesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.incentives.Gauge data */ 1:
                    message.data.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GaugesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.incentives.Gauge data = 1; */
        for (let i = 0; i < message.data.length; i++)
            Gauge.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.GaugesResponse
 */
export const GaugesResponse = new GaugesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGaugesRequest$Type extends MessageType<ActiveGaugesRequest> {
    constructor() {
        super("osmosis.incentives.ActiveGaugesRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<ActiveGaugesRequest>): ActiveGaugesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveGaugesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGaugesRequest): ActiveGaugesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGaugesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ActiveGaugesRequest
 */
export const ActiveGaugesRequest = new ActiveGaugesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGaugesResponse$Type extends MessageType<ActiveGaugesResponse> {
    constructor() {
        super("osmosis.incentives.ActiveGaugesResponse", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gauge, options: { "gogoproto.nullable": false } },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
        ]);
    }
    create(value?: PartialMessage<ActiveGaugesResponse>): ActiveGaugesResponse {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveGaugesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGaugesResponse): ActiveGaugesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.incentives.Gauge data */ 1:
                    message.data.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGaugesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.incentives.Gauge data = 1; */
        for (let i = 0; i < message.data.length; i++)
            Gauge.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ActiveGaugesResponse
 */
export const ActiveGaugesResponse = new ActiveGaugesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGaugesPerDenomRequest$Type extends MessageType<ActiveGaugesPerDenomRequest> {
    constructor() {
        super("osmosis.incentives.ActiveGaugesPerDenomRequest", [
            { no: 1, name: "denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<ActiveGaugesPerDenomRequest>): ActiveGaugesPerDenomRequest {
        const message = { denom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveGaugesPerDenomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGaugesPerDenomRequest): ActiveGaugesPerDenomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string denom */ 1:
                    message.denom = reader.string();
                    break;
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 2:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGaugesPerDenomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string denom = 1; */
        if (message.denom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.denom);
        /* cosmos.base.query.v1beta1.PageRequest pagination = 2; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ActiveGaugesPerDenomRequest
 */
export const ActiveGaugesPerDenomRequest = new ActiveGaugesPerDenomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveGaugesPerDenomResponse$Type extends MessageType<ActiveGaugesPerDenomResponse> {
    constructor() {
        super("osmosis.incentives.ActiveGaugesPerDenomResponse", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gauge, options: { "gogoproto.nullable": false } },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
        ]);
    }
    create(value?: PartialMessage<ActiveGaugesPerDenomResponse>): ActiveGaugesPerDenomResponse {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveGaugesPerDenomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveGaugesPerDenomResponse): ActiveGaugesPerDenomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.incentives.Gauge data */ 1:
                    message.data.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveGaugesPerDenomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.incentives.Gauge data = 1; */
        for (let i = 0; i < message.data.length; i++)
            Gauge.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.ActiveGaugesPerDenomResponse
 */
export const ActiveGaugesPerDenomResponse = new ActiveGaugesPerDenomResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpcomingGaugesRequest$Type extends MessageType<UpcomingGaugesRequest> {
    constructor() {
        super("osmosis.incentives.UpcomingGaugesRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<UpcomingGaugesRequest>): UpcomingGaugesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpcomingGaugesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpcomingGaugesRequest): UpcomingGaugesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpcomingGaugesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.UpcomingGaugesRequest
 */
export const UpcomingGaugesRequest = new UpcomingGaugesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpcomingGaugesResponse$Type extends MessageType<UpcomingGaugesResponse> {
    constructor() {
        super("osmosis.incentives.UpcomingGaugesResponse", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gauge, options: { "gogoproto.nullable": false } },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse }
        ]);
    }
    create(value?: PartialMessage<UpcomingGaugesResponse>): UpcomingGaugesResponse {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpcomingGaugesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpcomingGaugesResponse): UpcomingGaugesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated osmosis.incentives.Gauge data */ 1:
                    message.data.push(Gauge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpcomingGaugesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated osmosis.incentives.Gauge data = 1; */
        for (let i = 0; i < message.data.length; i++)
            Gauge.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.UpcomingGaugesResponse
 */
export const UpcomingGaugesResponse = new UpcomingGaugesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardsEstRequest$Type extends MessageType<RewardsEstRequest> {
    constructor() {
        super("osmosis.incentives.RewardsEstRequest", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"owner\"" } },
            { no: 2, name: "lock_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "end_epoch", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RewardsEstRequest>): RewardsEstRequest {
        const message = { owner: "", lockIds: [], endEpoch: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RewardsEstRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardsEstRequest): RewardsEstRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* repeated uint64 lock_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lockIds.push(reader.uint64().toBigInt());
                    else
                        message.lockIds.push(reader.uint64().toBigInt());
                    break;
                case /* int64 end_epoch */ 3:
                    message.endEpoch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardsEstRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* repeated uint64 lock_ids = 2; */
        if (message.lockIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lockIds.length; i++)
                writer.uint64(message.lockIds[i]);
            writer.join();
        }
        /* int64 end_epoch = 3; */
        if (message.endEpoch !== 0n)
            writer.tag(3, WireType.Varint).int64(message.endEpoch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.RewardsEstRequest
 */
export const RewardsEstRequest = new RewardsEstRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardsEstResponse$Type extends MessageType<RewardsEstResponse> {
    constructor() {
        super("osmosis.incentives.RewardsEstResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<RewardsEstResponse>): RewardsEstResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RewardsEstResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardsEstResponse): RewardsEstResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardsEstResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.RewardsEstResponse
 */
export const RewardsEstResponse = new RewardsEstResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLockableDurationsRequest$Type extends MessageType<QueryLockableDurationsRequest> {
    constructor() {
        super("osmosis.incentives.QueryLockableDurationsRequest", []);
    }
    create(value?: PartialMessage<QueryLockableDurationsRequest>): QueryLockableDurationsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryLockableDurationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLockableDurationsRequest): QueryLockableDurationsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryLockableDurationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.QueryLockableDurationsRequest
 */
export const QueryLockableDurationsRequest = new QueryLockableDurationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryLockableDurationsResponse$Type extends MessageType<QueryLockableDurationsResponse> {
    constructor() {
        super("osmosis.incentives.QueryLockableDurationsResponse", [
            { no: 1, name: "lockable_durations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Duration, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lockable_durations\"", "gogoproto.stdduration": true } }
        ]);
    }
    create(value?: PartialMessage<QueryLockableDurationsResponse>): QueryLockableDurationsResponse {
        const message = { lockableDurations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryLockableDurationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryLockableDurationsResponse): QueryLockableDurationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.Duration lockable_durations */ 1:
                    message.lockableDurations.push(Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryLockableDurationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.Duration lockable_durations = 1; */
        for (let i = 0; i < message.lockableDurations.length; i++)
            Duration.internalBinaryWrite(message.lockableDurations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.incentives.QueryLockableDurationsResponse
 */
export const QueryLockableDurationsResponse = new QueryLockableDurationsResponse$Type();
/**
 * @generated ServiceType for protobuf service osmosis.incentives.Query
 */
export const Query = new ServiceType("osmosis.incentives.Query", [
    { name: "ModuleToDistributeCoins", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/module_to_distribute_coins" } }, I: ModuleToDistributeCoinsRequest, O: ModuleToDistributeCoinsResponse },
    { name: "ModuleDistributedCoins", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/module_distributed_coins" } }, I: ModuleDistributedCoinsRequest, O: ModuleDistributedCoinsResponse },
    { name: "GaugeByID", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/gauge_by_id/{id}" } }, I: GaugeByIDRequest, O: GaugeByIDResponse },
    { name: "Gauges", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/gauges" } }, I: GaugesRequest, O: GaugesResponse },
    { name: "ActiveGauges", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/active_gauges" } }, I: ActiveGaugesRequest, O: ActiveGaugesResponse },
    { name: "ActiveGaugesPerDenom", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/active_gauges_per_denom" } }, I: ActiveGaugesPerDenomRequest, O: ActiveGaugesPerDenomResponse },
    { name: "UpcomingGauges", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/upcoming_gauges" } }, I: UpcomingGaugesRequest, O: UpcomingGaugesResponse },
    { name: "RewardsEst", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/rewards_est/{owner}" } }, I: RewardsEstRequest, O: RewardsEstResponse },
    { name: "LockableDurations", options: { "google.api.http": { get: "/osmosis/incentives/v1beta1/lockable_durations" } }, I: QueryLockableDurationsRequest, O: QueryLockableDurationsResponse }
]);
