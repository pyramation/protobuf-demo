// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/incentives/query.proto" (package "osmosis.incentives", syntax proto3),// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Query } from "./query";
import type { QueryLockableDurationsResponse } from "./query";
import type { QueryLockableDurationsRequest } from "./query";
import type { RewardsEstResponse } from "./query";
import type { RewardsEstRequest } from "./query";
import type { UpcomingGaugesResponse } from "./query";
import type { UpcomingGaugesRequest } from "./query";
import type { ActiveGaugesPerDenomResponse } from "./query";
import type { ActiveGaugesPerDenomRequest } from "./query";
import type { ActiveGaugesResponse } from "./query";
import type { ActiveGaugesRequest } from "./query";
import type { GaugesResponse } from "./query";
import type { GaugesRequest } from "./query";
import type { GaugeByIDResponse } from "./query";
import type { GaugeByIDRequest } from "./query";
import type { ModuleDistributedCoinsResponse } from "./query";
import type { ModuleDistributedCoinsRequest } from "./query";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ModuleToDistributeCoinsResponse } from "./query";
import type { ModuleToDistributeCoinsRequest } from "./query";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Query defines the gRPC querier service.
 *
 * @generated from protobuf service osmosis.incentives.Query
 */
export interface IQueryClient {
    /**
     * returns coins that is going to be distributed
     *
     * @generated from protobuf rpc: ModuleToDistributeCoins(osmosis.incentives.ModuleToDistributeCoinsRequest) returns (osmosis.incentives.ModuleToDistributeCoinsResponse);
     */
    moduleToDistributeCoins(input: ModuleToDistributeCoinsRequest, options?: RpcOptions): UnaryCall<ModuleToDistributeCoinsRequest, ModuleToDistributeCoinsResponse>;
    /**
     * returns coins that are distributed by module so far
     *
     * @generated from protobuf rpc: ModuleDistributedCoins(osmosis.incentives.ModuleDistributedCoinsRequest) returns (osmosis.incentives.ModuleDistributedCoinsResponse);
     */
    moduleDistributedCoins(input: ModuleDistributedCoinsRequest, options?: RpcOptions): UnaryCall<ModuleDistributedCoinsRequest, ModuleDistributedCoinsResponse>;
    /**
     * returns Gauge by id
     *
     * @generated from protobuf rpc: GaugeByID(osmosis.incentives.GaugeByIDRequest) returns (osmosis.incentives.GaugeByIDResponse);
     */
    gaugeByID(input: GaugeByIDRequest, options?: RpcOptions): UnaryCall<GaugeByIDRequest, GaugeByIDResponse>;
    /**
     * returns gauges both upcoming and active
     *
     * @generated from protobuf rpc: Gauges(osmosis.incentives.GaugesRequest) returns (osmosis.incentives.GaugesResponse);
     */
    gauges(input: GaugesRequest, options?: RpcOptions): UnaryCall<GaugesRequest, GaugesResponse>;
    /**
     * returns active gauges
     *
     * @generated from protobuf rpc: ActiveGauges(osmosis.incentives.ActiveGaugesRequest) returns (osmosis.incentives.ActiveGaugesResponse);
     */
    activeGauges(input: ActiveGaugesRequest, options?: RpcOptions): UnaryCall<ActiveGaugesRequest, ActiveGaugesResponse>;
    /**
     * @generated from protobuf rpc: ActiveGaugesPerDenom(osmosis.incentives.ActiveGaugesPerDenomRequest) returns (osmosis.incentives.ActiveGaugesPerDenomResponse);
     */
    activeGaugesPerDenom(input: ActiveGaugesPerDenomRequest, options?: RpcOptions): UnaryCall<ActiveGaugesPerDenomRequest, ActiveGaugesPerDenomResponse>;
    /**
     * returns scheduled gauges
     *
     * @generated from protobuf rpc: UpcomingGauges(osmosis.incentives.UpcomingGaugesRequest) returns (osmosis.incentives.UpcomingGaugesResponse);
     */
    upcomingGauges(input: UpcomingGaugesRequest, options?: RpcOptions): UnaryCall<UpcomingGaugesRequest, UpcomingGaugesResponse>;
    /**
     * RewardsEst returns an estimate of the rewards at a future specific time.
     * The querier either provides an address or a set of locks
     * for which they want to find the associated rewards.
     *
     * @generated from protobuf rpc: RewardsEst(osmosis.incentives.RewardsEstRequest) returns (osmosis.incentives.RewardsEstResponse);
     */
    rewardsEst(input: RewardsEstRequest, options?: RpcOptions): UnaryCall<RewardsEstRequest, RewardsEstResponse>;
    /**
     * returns lockable durations that are valid to give incentives
     *
     * @generated from protobuf rpc: LockableDurations(osmosis.incentives.QueryLockableDurationsRequest) returns (osmosis.incentives.QueryLockableDurationsResponse);
     */
    lockableDurations(input: QueryLockableDurationsRequest, options?: RpcOptions): UnaryCall<QueryLockableDurationsRequest, QueryLockableDurationsResponse>;
}
/**
 * Query defines the gRPC querier service.
 *
 * @generated from protobuf service osmosis.incentives.Query
 */
export class QueryClient implements IQueryClient, ServiceInfo {
    typeName = Query.typeName;
    methods = Query.methods;
    options = Query.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * returns coins that is going to be distributed
     *
     * @generated from protobuf rpc: ModuleToDistributeCoins(osmosis.incentives.ModuleToDistributeCoinsRequest) returns (osmosis.incentives.ModuleToDistributeCoinsResponse);
     */
    moduleToDistributeCoins(input: ModuleToDistributeCoinsRequest, options?: RpcOptions): UnaryCall<ModuleToDistributeCoinsRequest, ModuleToDistributeCoinsResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ModuleToDistributeCoinsRequest, ModuleToDistributeCoinsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns coins that are distributed by module so far
     *
     * @generated from protobuf rpc: ModuleDistributedCoins(osmosis.incentives.ModuleDistributedCoinsRequest) returns (osmosis.incentives.ModuleDistributedCoinsResponse);
     */
    moduleDistributedCoins(input: ModuleDistributedCoinsRequest, options?: RpcOptions): UnaryCall<ModuleDistributedCoinsRequest, ModuleDistributedCoinsResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<ModuleDistributedCoinsRequest, ModuleDistributedCoinsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns Gauge by id
     *
     * @generated from protobuf rpc: GaugeByID(osmosis.incentives.GaugeByIDRequest) returns (osmosis.incentives.GaugeByIDResponse);
     */
    gaugeByID(input: GaugeByIDRequest, options?: RpcOptions): UnaryCall<GaugeByIDRequest, GaugeByIDResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<GaugeByIDRequest, GaugeByIDResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns gauges both upcoming and active
     *
     * @generated from protobuf rpc: Gauges(osmosis.incentives.GaugesRequest) returns (osmosis.incentives.GaugesResponse);
     */
    gauges(input: GaugesRequest, options?: RpcOptions): UnaryCall<GaugesRequest, GaugesResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<GaugesRequest, GaugesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns active gauges
     *
     * @generated from protobuf rpc: ActiveGauges(osmosis.incentives.ActiveGaugesRequest) returns (osmosis.incentives.ActiveGaugesResponse);
     */
    activeGauges(input: ActiveGaugesRequest, options?: RpcOptions): UnaryCall<ActiveGaugesRequest, ActiveGaugesResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<ActiveGaugesRequest, ActiveGaugesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: ActiveGaugesPerDenom(osmosis.incentives.ActiveGaugesPerDenomRequest) returns (osmosis.incentives.ActiveGaugesPerDenomResponse);
     */
    activeGaugesPerDenom(input: ActiveGaugesPerDenomRequest, options?: RpcOptions): UnaryCall<ActiveGaugesPerDenomRequest, ActiveGaugesPerDenomResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<ActiveGaugesPerDenomRequest, ActiveGaugesPerDenomResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns scheduled gauges
     *
     * @generated from protobuf rpc: UpcomingGauges(osmosis.incentives.UpcomingGaugesRequest) returns (osmosis.incentives.UpcomingGaugesResponse);
     */
    upcomingGauges(input: UpcomingGaugesRequest, options?: RpcOptions): UnaryCall<UpcomingGaugesRequest, UpcomingGaugesResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpcomingGaugesRequest, UpcomingGaugesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RewardsEst returns an estimate of the rewards at a future specific time.
     * The querier either provides an address or a set of locks
     * for which they want to find the associated rewards.
     *
     * @generated from protobuf rpc: RewardsEst(osmosis.incentives.RewardsEstRequest) returns (osmosis.incentives.RewardsEstResponse);
     */
    rewardsEst(input: RewardsEstRequest, options?: RpcOptions): UnaryCall<RewardsEstRequest, RewardsEstResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<RewardsEstRequest, RewardsEstResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * returns lockable durations that are valid to give incentives
     *
     * @generated from protobuf rpc: LockableDurations(osmosis.incentives.QueryLockableDurationsRequest) returns (osmosis.incentives.QueryLockableDurationsResponse);
     */
    lockableDurations(input: QueryLockableDurationsRequest, options?: RpcOptions): UnaryCall<QueryLockableDurationsRequest, QueryLockableDurationsResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryLockableDurationsRequest, QueryLockableDurationsResponse>("unary", this._transport, method, opt, input);
    }
}
