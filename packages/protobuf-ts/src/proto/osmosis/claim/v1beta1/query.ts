// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "osmosis/claim/v1beta1/query.proto" (package "osmosis.claim.v1beta1", syntax proto3),// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Action } from "./claim";
import { ClaimRecord } from "./claim";
import { Params } from "./params";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
/**
 * QueryParamsRequest is the request type for the Query/Params RPC method.
 *
 * @generated from protobuf message osmosis.claim.v1beta1.QueryModuleAccountBalanceRequest
 */
export interface QueryModuleAccountBalanceRequest {
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message osmosis.claim.v1beta1.QueryModuleAccountBalanceResponse
 */
export interface QueryModuleAccountBalanceResponse {
    /**
     * params defines the parameters of the module.
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin moduleAccountBalance = 1;
     */
    moduleAccountBalance: Coin[];
}
/**
 * QueryParamsRequest is the request type for the Query/Params RPC method.
 *
 * @generated from protobuf message osmosis.claim.v1beta1.QueryParamsRequest
 */
export interface QueryParamsRequest {
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 *
 * @generated from protobuf message osmosis.claim.v1beta1.QueryParamsResponse
 */
export interface QueryParamsResponse {
    /**
     * params defines the parameters of the module.
     *
     * @generated from protobuf field: osmosis.claim.v1beta1.Params params = 1;
     */
    params?: Params;
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryClaimRecordRequest
 */
export interface QueryClaimRecordRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryClaimRecordResponse
 */
export interface QueryClaimRecordResponse {
    /**
     * @generated from protobuf field: osmosis.claim.v1beta1.ClaimRecord claim_record = 1;
     */
    claimRecord?: ClaimRecord;
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryClaimableForActionRequest
 */
export interface QueryClaimableForActionRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: osmosis.claim.v1beta1.Action action = 2;
     */
    action: Action;
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryClaimableForActionResponse
 */
export interface QueryClaimableForActionResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryTotalClaimableRequest
 */
export interface QueryTotalClaimableRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message osmosis.claim.v1beta1.QueryTotalClaimableResponse
 */
export interface QueryTotalClaimableResponse {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleAccountBalanceRequest$Type extends MessageType<QueryModuleAccountBalanceRequest> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryModuleAccountBalanceRequest", []);
    }
    create(value?: PartialMessage<QueryModuleAccountBalanceRequest>): QueryModuleAccountBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryModuleAccountBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleAccountBalanceRequest): QueryModuleAccountBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryModuleAccountBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryModuleAccountBalanceRequest
 */
export const QueryModuleAccountBalanceRequest = new QueryModuleAccountBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryModuleAccountBalanceResponse$Type extends MessageType<QueryModuleAccountBalanceResponse> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryModuleAccountBalanceResponse", [
            { no: 1, name: "moduleAccountBalance", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"coins\"", "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<QueryModuleAccountBalanceResponse>): QueryModuleAccountBalanceResponse {
        const message = { moduleAccountBalance: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryModuleAccountBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryModuleAccountBalanceResponse): QueryModuleAccountBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin moduleAccountBalance */ 1:
                    message.moduleAccountBalance.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryModuleAccountBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin moduleAccountBalance = 1; */
        for (let i = 0; i < message.moduleAccountBalance.length; i++)
            Coin.internalBinaryWrite(message.moduleAccountBalance[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryModuleAccountBalanceResponse
 */
export const QueryModuleAccountBalanceResponse = new QueryModuleAccountBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryParamsRequest", []);
    }
    create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsRequest): QueryParamsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryParamsResponse", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsResponse): QueryParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* osmosis.claim.v1beta1.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* osmosis.claim.v1beta1.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryClaimRecordRequest$Type extends MessageType<QueryClaimRecordRequest> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryClaimRecordRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } }
        ]);
    }
    create(value?: PartialMessage<QueryClaimRecordRequest>): QueryClaimRecordRequest {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryClaimRecordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryClaimRecordRequest): QueryClaimRecordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryClaimRecordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryClaimRecordRequest
 */
export const QueryClaimRecordRequest = new QueryClaimRecordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryClaimRecordResponse$Type extends MessageType<QueryClaimRecordResponse> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryClaimRecordResponse", [
            { no: 1, name: "claim_record", kind: "message", T: () => ClaimRecord, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"claim_record\"" } }
        ]);
    }
    create(value?: PartialMessage<QueryClaimRecordResponse>): QueryClaimRecordResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryClaimRecordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryClaimRecordResponse): QueryClaimRecordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* osmosis.claim.v1beta1.ClaimRecord claim_record */ 1:
                    message.claimRecord = ClaimRecord.internalBinaryRead(reader, reader.uint32(), options, message.claimRecord);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryClaimRecordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* osmosis.claim.v1beta1.ClaimRecord claim_record = 1; */
        if (message.claimRecord)
            ClaimRecord.internalBinaryWrite(message.claimRecord, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryClaimRecordResponse
 */
export const QueryClaimRecordResponse = new QueryClaimRecordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryClaimableForActionRequest$Type extends MessageType<QueryClaimableForActionRequest> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryClaimableForActionRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"address\"" } },
            { no: 2, name: "action", kind: "enum", T: () => ["osmosis.claim.v1beta1.Action", Action], options: { "gogoproto.moretags": "yaml:\"action\"" } }
        ]);
    }
    create(value?: PartialMessage<QueryClaimableForActionRequest>): QueryClaimableForActionRequest {
        const message = { address: "", action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryClaimableForActionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryClaimableForActionRequest): QueryClaimableForActionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* osmosis.claim.v1beta1.Action action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryClaimableForActionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* osmosis.claim.v1beta1.Action action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryClaimableForActionRequest
 */
export const QueryClaimableForActionRequest = new QueryClaimableForActionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryClaimableForActionResponse$Type extends MessageType<QueryClaimableForActionResponse> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryClaimableForActionResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"coins\"", "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<QueryClaimableForActionResponse>): QueryClaimableForActionResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryClaimableForActionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryClaimableForActionResponse): QueryClaimableForActionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryClaimableForActionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryClaimableForActionResponse
 */
export const QueryClaimableForActionResponse = new QueryClaimableForActionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalClaimableRequest$Type extends MessageType<QueryTotalClaimableRequest> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryTotalClaimableRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"address\"" } }
        ]);
    }
    create(value?: PartialMessage<QueryTotalClaimableRequest>): QueryTotalClaimableRequest {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalClaimableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalClaimableRequest): QueryTotalClaimableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTotalClaimableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryTotalClaimableRequest
 */
export const QueryTotalClaimableRequest = new QueryTotalClaimableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalClaimableResponse$Type extends MessageType<QueryTotalClaimableResponse> {
    constructor() {
        super("osmosis.claim.v1beta1.QueryTotalClaimableResponse", [
            { no: 1, name: "coins", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"coins\"", "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } }
        ]);
    }
    create(value?: PartialMessage<QueryTotalClaimableResponse>): QueryTotalClaimableResponse {
        const message = { coins: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalClaimableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalClaimableResponse): QueryTotalClaimableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin coins */ 1:
                    message.coins.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTotalClaimableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin coins = 1; */
        for (let i = 0; i < message.coins.length; i++)
            Coin.internalBinaryWrite(message.coins[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osmosis.claim.v1beta1.QueryTotalClaimableResponse
 */
export const QueryTotalClaimableResponse = new QueryTotalClaimableResponse$Type();
/**
 * @generated ServiceType for protobuf service osmosis.claim.v1beta1.Query
 */
export const Query = new ServiceType("osmosis.claim.v1beta1.Query", [
    { name: "ModuleAccountBalance", options: { "google.api.http": { get: "/osmosis/claim/v1beta1/module_account_balance" } }, I: QueryModuleAccountBalanceRequest, O: QueryModuleAccountBalanceResponse },
    { name: "Params", options: { "google.api.http": { get: "/osmosis/claim/v1beta1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
    { name: "ClaimRecord", options: { "google.api.http": { get: "/osmosis/claim/v1beta1/claim_record/{address}" } }, I: QueryClaimRecordRequest, O: QueryClaimRecordResponse },
    { name: "ClaimableForAction", options: { "google.api.http": { get: "/osmosis/claim/v1beta1/claimable_for_action/{address}/{action}" } }, I: QueryClaimableForActionRequest, O: QueryClaimableForActionResponse },
    { name: "TotalClaimable", options: { "google.api.http": { get: "/osmosis/claim/v1beta1/total_claimable/{address}" } }, I: QueryTotalClaimableRequest, O: QueryTotalClaimableResponse }
]);
