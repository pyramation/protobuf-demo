// @generated by protobuf-ts 2.4.0,// @generated from protobuf file "cosmos/group/v1/tx.proto" (package "cosmos.group.v1", syntax proto3),// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { VoteOption } from "./types";
import { Any } from "../../../google/protobuf/any";
import { Member } from "./types";
// 
// Groups
// 

/**
 * MsgCreateGroup is the Msg/CreateGroup request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroup
 */
export interface MsgCreateGroup {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * members defines the group members.
     *
     * @generated from protobuf field: repeated cosmos.group.v1.Member members = 2;
     */
    members: Member[];
    /**
     * metadata is any arbitrary metadata to attached to the group.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
}
/**
 * MsgCreateGroupResponse is the Msg/CreateGroup response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroupResponse
 */
export interface MsgCreateGroupResponse {
    /**
     * group_id is the unique ID of the newly created group.
     *
     * @generated from protobuf field: uint64 group_id = 1;
     */
    groupId: bigint;
}
/**
 * MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupMembers
 */
export interface MsgUpdateGroupMembers {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * group_id is the unique ID of the group.
     *
     * @generated from protobuf field: uint64 group_id = 2;
     */
    groupId: bigint;
    /**
     * member_updates is the list of members to update,
     * set weight to 0 to remove a member.
     *
     * @generated from protobuf field: repeated cosmos.group.v1.Member member_updates = 3;
     */
    memberUpdates: Member[];
}
/**
 * MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupMembersResponse
 */
export interface MsgUpdateGroupMembersResponse {
}
/**
 * MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupAdmin
 */
export interface MsgUpdateGroupAdmin {
    /**
     * admin is the current account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * group_id is the unique ID of the group.
     *
     * @generated from protobuf field: uint64 group_id = 2;
     */
    groupId: bigint;
    /**
     * new_admin is the group new admin account address.
     *
     * @generated from protobuf field: string new_admin = 3;
     */
    newAdmin: string;
}
/**
 * MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupAdminResponse
 */
export interface MsgUpdateGroupAdminResponse {
}
/**
 * MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupMetadata
 */
export interface MsgUpdateGroupMetadata {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * group_id is the unique ID of the group.
     *
     * @generated from protobuf field: uint64 group_id = 2;
     */
    groupId: bigint;
    /**
     * metadata is the updated group's metadata.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
}
/**
 * MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupMetadataResponse
 */
export interface MsgUpdateGroupMetadataResponse {
}
// 
// Group Policies
// 

/**
 * MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroupPolicy
 */
export interface MsgCreateGroupPolicy {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * group_id is the unique ID of the group.
     *
     * @generated from protobuf field: uint64 group_id = 2;
     */
    groupId: bigint;
    /**
     * metadata is any arbitrary metadata attached to the group policy.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
    /**
     * decision_policy specifies the group policy's decision policy.
     *
     * @generated from protobuf field: google.protobuf.Any decision_policy = 4;
     */
    decisionPolicy?: Any;
}
/**
 * MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroupPolicyResponse
 */
export interface MsgCreateGroupPolicyResponse {
    /**
     * address is the account address of the newly created group policy.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyAdmin
 */
export interface MsgUpdateGroupPolicyAdmin {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * address is the account address of the group policy.
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * new_admin is the new group policy admin.
     *
     * @generated from protobuf field: string new_admin = 3;
     */
    newAdmin: string;
}
/**
 * MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroupWithPolicy
 */
export interface MsgCreateGroupWithPolicy {
    /**
     * admin is the account address of the group and group policy admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * members defines the group members.
     *
     * @generated from protobuf field: repeated cosmos.group.v1.Member members = 2;
     */
    members: Member[];
    /**
     * group_metadata is any arbitrary metadata attached to the group.
     *
     * @generated from protobuf field: string group_metadata = 3;
     */
    groupMetadata: string;
    /**
     * group_policy_metadata is any arbitrary metadata attached to the group policy.
     *
     * @generated from protobuf field: string group_policy_metadata = 4;
     */
    groupPolicyMetadata: string;
    /**
     * group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.
     *
     * @generated from protobuf field: bool group_policy_as_admin = 5;
     */
    groupPolicyAsAdmin: boolean;
    /**
     * decision_policy specifies the group policy's decision policy.
     *
     * @generated from protobuf field: google.protobuf.Any decision_policy = 6;
     */
    decisionPolicy?: Any;
}
/**
 * MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgCreateGroupWithPolicyResponse
 */
export interface MsgCreateGroupWithPolicyResponse {
    /**
     * group_id is the unique ID of the newly created group with policy.
     *
     * @generated from protobuf field: uint64 group_id = 1;
     */
    groupId: bigint;
    /**
     * group_policy_address is the account address of the newly created group policy.
     *
     * @generated from protobuf field: string group_policy_address = 2;
     */
    groupPolicyAddress: string;
}
/**
 * MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse
 */
export interface MsgUpdateGroupPolicyAdminResponse {
}
/**
 * MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy
 */
export interface MsgUpdateGroupPolicyDecisionPolicy {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * address is the account address of group policy.
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * decision_policy is the updated group policy's decision policy.
     *
     * @generated from protobuf field: google.protobuf.Any decision_policy = 3;
     */
    decisionPolicy?: Any;
}
/**
 * MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse
 */
export interface MsgUpdateGroupPolicyDecisionPolicyResponse {
}
/**
 * MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyMetadata
 */
export interface MsgUpdateGroupPolicyMetadata {
    /**
     * admin is the account address of the group admin.
     *
     * @generated from protobuf field: string admin = 1;
     */
    admin: string;
    /**
     * address is the account address of group policy.
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * metadata is the updated group policy metadata.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
}
/**
 * MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse
 */
export interface MsgUpdateGroupPolicyMetadataResponse {
}
/**
 * MsgSubmitProposal is the Msg/SubmitProposal request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgSubmitProposal
 */
export interface MsgSubmitProposal {
    /**
     * address is the account address of group policy.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * proposers are the account addresses of the proposers.
     * Proposers signatures will be counted as yes votes.
     *
     * @generated from protobuf field: repeated string proposers = 2;
     */
    proposers: string[];
    /**
     * metadata is any arbitrary metadata to attached to the proposal.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
    /**
     * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
     *
     * @generated from protobuf field: repeated google.protobuf.Any messages = 4;
     */
    messages: Any[];
    /**
     * exec defines the mode of execution of the proposal,
     * whether it should be executed immediately on creation or not.
     * If so, proposers signatures are considered as Yes votes.
     *
     * @generated from protobuf field: cosmos.group.v1.Exec exec = 5;
     */
    exec: Exec;
}
/**
 * MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgSubmitProposalResponse
 */
export interface MsgSubmitProposalResponse {
    /**
     * proposal is the unique ID of the proposal.
     *
     * @generated from protobuf field: uint64 proposal_id = 1;
     */
    proposalId: bigint;
}
/**
 * MsgWithdrawProposal is the Msg/WithdrawProposal request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgWithdrawProposal
 */
export interface MsgWithdrawProposal {
    /**
     * proposal is the unique ID of the proposal.
     *
     * @generated from protobuf field: uint64 proposal_id = 1;
     */
    proposalId: bigint;
    /**
     * address is the admin of the group policy or one of the proposer of the proposal.
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
}
/**
 * MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgWithdrawProposalResponse
 */
export interface MsgWithdrawProposalResponse {
}
/**
 * MsgVote is the Msg/Vote request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgVote
 */
export interface MsgVote {
    /**
     * proposal is the unique ID of the proposal.
     *
     * @generated from protobuf field: uint64 proposal_id = 1;
     */
    proposalId: bigint;
    /**
     * voter is the voter account address.
     *
     * @generated from protobuf field: string voter = 2;
     */
    voter: string;
    /**
     * option is the voter's choice on the proposal.
     *
     * @generated from protobuf field: cosmos.group.v1.VoteOption option = 3;
     */
    option: VoteOption;
    /**
     * metadata is any arbitrary metadata to attached to the vote.
     *
     * @generated from protobuf field: string metadata = 4;
     */
    metadata: string;
    /**
     * exec defines whether the proposal should be executed
     * immediately after voting or not.
     *
     * @generated from protobuf field: cosmos.group.v1.Exec exec = 5;
     */
    exec: Exec;
}
/**
 * MsgVoteResponse is the Msg/Vote response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgVoteResponse
 */
export interface MsgVoteResponse {
}
/**
 * MsgExec is the Msg/Exec request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgExec
 */
export interface MsgExec {
    /**
     * proposal is the unique ID of the proposal.
     *
     * @generated from protobuf field: uint64 proposal_id = 1;
     */
    proposalId: bigint;
    /**
     * signer is the account address used to execute the proposal.
     *
     * @generated from protobuf field: string signer = 2;
     */
    signer: string;
}
/**
 * MsgExecResponse is the Msg/Exec request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgExecResponse
 */
export interface MsgExecResponse {
}
/**
 * MsgLeaveGroup is the Msg/LeaveGroup request type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgLeaveGroup
 */
export interface MsgLeaveGroup {
    /**
     * address is the account address of the group member.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * group_id is the unique ID of the group.
     *
     * @generated from protobuf field: uint64 group_id = 2;
     */
    groupId: bigint;
}
/**
 * MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
 *
 * @generated from protobuf message cosmos.group.v1.MsgLeaveGroupResponse
 */
export interface MsgLeaveGroupResponse {
}
// 
// Proposals and Voting
// 

/**
 * Exec defines modes of execution of a proposal on creation or on new vote.
 *
 * @generated from protobuf enum cosmos.group.v1.Exec
 */
export enum Exec {
    /**
     * An empty value means that there should be a separate
     * MsgExec request for the proposal to execute.
     *
     * @generated from protobuf enum value: EXEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Try to execute the proposal immediately.
     * If the proposal is not allowed per the DecisionPolicy,
     * the proposal will still be open and could
     * be executed at a later point.
     *
     * @generated from protobuf enum value: EXEC_TRY = 1;
     */
    TRY = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroup$Type extends MessageType<MsgCreateGroup> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroup", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member, options: { "gogoproto.nullable": false } },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgCreateGroup>): MsgCreateGroup {
        const message = { admin: "", members: [], metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroup): MsgCreateGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* repeated cosmos.group.v1.Member members */ 2:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* repeated cosmos.group.v1.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroup
 */
export const MsgCreateGroup = new MsgCreateGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroupResponse$Type extends MessageType<MsgCreateGroupResponse> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroupResponse", [
            { no: 1, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MsgCreateGroupResponse>): MsgCreateGroupResponse {
        const message = { groupId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroupResponse): MsgCreateGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 group_id */ 1:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 group_id = 1; */
        if (message.groupId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroupResponse
 */
export const MsgCreateGroupResponse = new MsgCreateGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupMembers$Type extends MessageType<MsgUpdateGroupMembers> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupMembers", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "member_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member, options: { "gogoproto.nullable": false } }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupMembers>): MsgUpdateGroupMembers {
        const message = { admin: "", groupId: 0n, memberUpdates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupMembers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupMembers): MsgUpdateGroupMembers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* uint64 group_id */ 2:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                case /* repeated cosmos.group.v1.Member member_updates */ 3:
                    message.memberUpdates.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupMembers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* uint64 group_id = 2; */
        if (message.groupId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.groupId);
        /* repeated cosmos.group.v1.Member member_updates = 3; */
        for (let i = 0; i < message.memberUpdates.length; i++)
            Member.internalBinaryWrite(message.memberUpdates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupMembers
 */
export const MsgUpdateGroupMembers = new MsgUpdateGroupMembers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupMembersResponse$Type extends MessageType<MsgUpdateGroupMembersResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupMembersResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupMembersResponse>): MsgUpdateGroupMembersResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupMembersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupMembersResponse): MsgUpdateGroupMembersResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupMembersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupMembersResponse
 */
export const MsgUpdateGroupMembersResponse = new MsgUpdateGroupMembersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupAdmin$Type extends MessageType<MsgUpdateGroupAdmin> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupAdmin", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "new_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupAdmin>): MsgUpdateGroupAdmin {
        const message = { admin: "", groupId: 0n, newAdmin: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupAdmin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupAdmin): MsgUpdateGroupAdmin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* uint64 group_id */ 2:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                case /* string new_admin */ 3:
                    message.newAdmin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupAdmin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* uint64 group_id = 2; */
        if (message.groupId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.groupId);
        /* string new_admin = 3; */
        if (message.newAdmin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupAdmin
 */
export const MsgUpdateGroupAdmin = new MsgUpdateGroupAdmin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupAdminResponse$Type extends MessageType<MsgUpdateGroupAdminResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupAdminResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupAdminResponse>): MsgUpdateGroupAdminResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupAdminResponse): MsgUpdateGroupAdminResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupAdminResponse
 */
export const MsgUpdateGroupAdminResponse = new MsgUpdateGroupAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupMetadata$Type extends MessageType<MsgUpdateGroupMetadata> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupMetadata", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupMetadata>): MsgUpdateGroupMetadata {
        const message = { admin: "", groupId: 0n, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupMetadata): MsgUpdateGroupMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* uint64 group_id */ 2:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* uint64 group_id = 2; */
        if (message.groupId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.groupId);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupMetadata
 */
export const MsgUpdateGroupMetadata = new MsgUpdateGroupMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupMetadataResponse$Type extends MessageType<MsgUpdateGroupMetadataResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupMetadataResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupMetadataResponse>): MsgUpdateGroupMetadataResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupMetadataResponse): MsgUpdateGroupMetadataResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupMetadataResponse
 */
export const MsgUpdateGroupMetadataResponse = new MsgUpdateGroupMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroupPolicy$Type extends MessageType<MsgCreateGroupPolicy> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroupPolicy", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "decision_policy", kind: "message", T: () => Any, options: { "cosmos_proto.accepts_interface": "DecisionPolicy" } }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgCreateGroupPolicy>): MsgCreateGroupPolicy {
        const message = { admin: "", groupId: 0n, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroupPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroupPolicy): MsgCreateGroupPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* uint64 group_id */ 2:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                case /* google.protobuf.Any decision_policy */ 4:
                    message.decisionPolicy = Any.internalBinaryRead(reader, reader.uint32(), options, message.decisionPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroupPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* uint64 group_id = 2; */
        if (message.groupId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.groupId);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        /* google.protobuf.Any decision_policy = 4; */
        if (message.decisionPolicy)
            Any.internalBinaryWrite(message.decisionPolicy, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroupPolicy
 */
export const MsgCreateGroupPolicy = new MsgCreateGroupPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroupPolicyResponse$Type extends MessageType<MsgCreateGroupPolicyResponse> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroupPolicyResponse", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ]);
    }
    create(value?: PartialMessage<MsgCreateGroupPolicyResponse>): MsgCreateGroupPolicyResponse {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroupPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroupPolicyResponse): MsgCreateGroupPolicyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroupPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroupPolicyResponse
 */
export const MsgCreateGroupPolicyResponse = new MsgCreateGroupPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyAdmin$Type extends MessageType<MsgUpdateGroupPolicyAdmin> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyAdmin", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "new_admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyAdmin>): MsgUpdateGroupPolicyAdmin {
        const message = { admin: "", address: "", newAdmin: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyAdmin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyAdmin): MsgUpdateGroupPolicyAdmin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string new_admin */ 3:
                    message.newAdmin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyAdmin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string new_admin = 3; */
        if (message.newAdmin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyAdmin
 */
export const MsgUpdateGroupPolicyAdmin = new MsgUpdateGroupPolicyAdmin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroupWithPolicy$Type extends MessageType<MsgCreateGroupWithPolicy> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroupWithPolicy", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Member, options: { "gogoproto.nullable": false } },
            { no: 3, name: "group_metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "group_policy_metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "group_policy_as_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "decision_policy", kind: "message", T: () => Any, options: { "cosmos_proto.accepts_interface": "DecisionPolicy" } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<MsgCreateGroupWithPolicy>): MsgCreateGroupWithPolicy {
        const message = { admin: "", members: [], groupMetadata: "", groupPolicyMetadata: "", groupPolicyAsAdmin: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroupWithPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroupWithPolicy): MsgCreateGroupWithPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* repeated cosmos.group.v1.Member members */ 2:
                    message.members.push(Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string group_metadata */ 3:
                    message.groupMetadata = reader.string();
                    break;
                case /* string group_policy_metadata */ 4:
                    message.groupPolicyMetadata = reader.string();
                    break;
                case /* bool group_policy_as_admin */ 5:
                    message.groupPolicyAsAdmin = reader.bool();
                    break;
                case /* google.protobuf.Any decision_policy */ 6:
                    message.decisionPolicy = Any.internalBinaryRead(reader, reader.uint32(), options, message.decisionPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroupWithPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* repeated cosmos.group.v1.Member members = 2; */
        for (let i = 0; i < message.members.length; i++)
            Member.internalBinaryWrite(message.members[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string group_metadata = 3; */
        if (message.groupMetadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.groupMetadata);
        /* string group_policy_metadata = 4; */
        if (message.groupPolicyMetadata !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.groupPolicyMetadata);
        /* bool group_policy_as_admin = 5; */
        if (message.groupPolicyAsAdmin !== false)
            writer.tag(5, WireType.Varint).bool(message.groupPolicyAsAdmin);
        /* google.protobuf.Any decision_policy = 6; */
        if (message.decisionPolicy)
            Any.internalBinaryWrite(message.decisionPolicy, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroupWithPolicy
 */
export const MsgCreateGroupWithPolicy = new MsgCreateGroupWithPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgCreateGroupWithPolicyResponse$Type extends MessageType<MsgCreateGroupWithPolicyResponse> {
    constructor() {
        super("cosmos.group.v1.MsgCreateGroupWithPolicyResponse", [
            { no: 1, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "group_policy_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ]);
    }
    create(value?: PartialMessage<MsgCreateGroupWithPolicyResponse>): MsgCreateGroupWithPolicyResponse {
        const message = { groupId: 0n, groupPolicyAddress: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgCreateGroupWithPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgCreateGroupWithPolicyResponse): MsgCreateGroupWithPolicyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 group_id */ 1:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                case /* string group_policy_address */ 2:
                    message.groupPolicyAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgCreateGroupWithPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 group_id = 1; */
        if (message.groupId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.groupId);
        /* string group_policy_address = 2; */
        if (message.groupPolicyAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.groupPolicyAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgCreateGroupWithPolicyResponse
 */
export const MsgCreateGroupWithPolicyResponse = new MsgCreateGroupWithPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyAdminResponse$Type extends MessageType<MsgUpdateGroupPolicyAdminResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyAdminResponse>): MsgUpdateGroupPolicyAdminResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyAdminResponse): MsgUpdateGroupPolicyAdminResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse
 */
export const MsgUpdateGroupPolicyAdminResponse = new MsgUpdateGroupPolicyAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyDecisionPolicy$Type extends MessageType<MsgUpdateGroupPolicyDecisionPolicy> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "decision_policy", kind: "message", T: () => Any, options: { "cosmos_proto.accepts_interface": "DecisionPolicy" } }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyDecisionPolicy>): MsgUpdateGroupPolicyDecisionPolicy {
        const message = { admin: "", address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyDecisionPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyDecisionPolicy): MsgUpdateGroupPolicyDecisionPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* google.protobuf.Any decision_policy */ 3:
                    message.decisionPolicy = Any.internalBinaryRead(reader, reader.uint32(), options, message.decisionPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyDecisionPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* google.protobuf.Any decision_policy = 3; */
        if (message.decisionPolicy)
            Any.internalBinaryWrite(message.decisionPolicy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy
 */
export const MsgUpdateGroupPolicyDecisionPolicy = new MsgUpdateGroupPolicyDecisionPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyDecisionPolicyResponse$Type extends MessageType<MsgUpdateGroupPolicyDecisionPolicyResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyDecisionPolicyResponse>): MsgUpdateGroupPolicyDecisionPolicyResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyDecisionPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyDecisionPolicyResponse): MsgUpdateGroupPolicyDecisionPolicyResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyDecisionPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse
 */
export const MsgUpdateGroupPolicyDecisionPolicyResponse = new MsgUpdateGroupPolicyDecisionPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyMetadata$Type extends MessageType<MsgUpdateGroupPolicyMetadata> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyMetadata", [
            { no: 1, name: "admin", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "cosmos.msg.v1.signer": ["admin"] });
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyMetadata>): MsgUpdateGroupPolicyMetadata {
        const message = { admin: "", address: "", metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyMetadata): MsgUpdateGroupPolicyMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string admin */ 1:
                    message.admin = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string admin = 1; */
        if (message.admin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.admin);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyMetadata
 */
export const MsgUpdateGroupPolicyMetadata = new MsgUpdateGroupPolicyMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateGroupPolicyMetadataResponse$Type extends MessageType<MsgUpdateGroupPolicyMetadataResponse> {
    constructor() {
        super("cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateGroupPolicyMetadataResponse>): MsgUpdateGroupPolicyMetadataResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateGroupPolicyMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateGroupPolicyMetadataResponse): MsgUpdateGroupPolicyMetadataResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgUpdateGroupPolicyMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse
 */
export const MsgUpdateGroupPolicyMetadataResponse = new MsgUpdateGroupPolicyMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubmitProposal$Type extends MessageType<MsgSubmitProposal> {
    constructor() {
        super("cosmos.group.v1.MsgSubmitProposal", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "proposers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 5, name: "exec", kind: "enum", T: () => ["cosmos.group.v1.Exec", Exec, "EXEC_"] }
        ], { "gogoproto.goproto_getters": false, "cosmos.msg.v1.signer": ["proposers"] });
    }
    create(value?: PartialMessage<MsgSubmitProposal>): MsgSubmitProposal {
        const message = { address: "", proposers: [], metadata: "", messages: [], exec: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSubmitProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubmitProposal): MsgSubmitProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* repeated string proposers */ 2:
                    message.proposers.push(reader.string());
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                case /* repeated google.protobuf.Any messages */ 4:
                    message.messages.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.group.v1.Exec exec */ 5:
                    message.exec = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubmitProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* repeated string proposers = 2; */
        for (let i = 0; i < message.proposers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.proposers[i]);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        /* repeated google.protobuf.Any messages = 4; */
        for (let i = 0; i < message.messages.length; i++)
            Any.internalBinaryWrite(message.messages[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.group.v1.Exec exec = 5; */
        if (message.exec !== 0)
            writer.tag(5, WireType.Varint).int32(message.exec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgSubmitProposal
 */
export const MsgSubmitProposal = new MsgSubmitProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSubmitProposalResponse$Type extends MessageType<MsgSubmitProposalResponse> {
    constructor() {
        super("cosmos.group.v1.MsgSubmitProposalResponse", [
            { no: 1, name: "proposal_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MsgSubmitProposalResponse>): MsgSubmitProposalResponse {
        const message = { proposalId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSubmitProposalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSubmitProposalResponse): MsgSubmitProposalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 proposal_id */ 1:
                    message.proposalId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSubmitProposalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 proposal_id = 1; */
        if (message.proposalId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.proposalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgSubmitProposalResponse
 */
export const MsgSubmitProposalResponse = new MsgSubmitProposalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawProposal$Type extends MessageType<MsgWithdrawProposal> {
    constructor() {
        super("cosmos.group.v1.MsgWithdrawProposal", [
            { no: 1, name: "proposal_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ]);
    }
    create(value?: PartialMessage<MsgWithdrawProposal>): MsgWithdrawProposal {
        const message = { proposalId: 0n, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawProposal): MsgWithdrawProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 proposal_id */ 1:
                    message.proposalId = reader.uint64().toBigInt();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgWithdrawProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 proposal_id = 1; */
        if (message.proposalId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.proposalId);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgWithdrawProposal
 */
export const MsgWithdrawProposal = new MsgWithdrawProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgWithdrawProposalResponse$Type extends MessageType<MsgWithdrawProposalResponse> {
    constructor() {
        super("cosmos.group.v1.MsgWithdrawProposalResponse", []);
    }
    create(value?: PartialMessage<MsgWithdrawProposalResponse>): MsgWithdrawProposalResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgWithdrawProposalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgWithdrawProposalResponse): MsgWithdrawProposalResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgWithdrawProposalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgWithdrawProposalResponse
 */
export const MsgWithdrawProposalResponse = new MsgWithdrawProposalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgVote$Type extends MessageType<MsgVote> {
    constructor() {
        super("cosmos.group.v1.MsgVote", [
            { no: 1, name: "proposal_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "voter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 3, name: "option", kind: "enum", T: () => ["cosmos.group.v1.VoteOption", VoteOption, "VOTE_OPTION_"] },
            { no: 4, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "exec", kind: "enum", T: () => ["cosmos.group.v1.Exec", Exec, "EXEC_"] }
        ], { "cosmos.msg.v1.signer": ["voter"] });
    }
    create(value?: PartialMessage<MsgVote>): MsgVote {
        const message = { proposalId: 0n, voter: "", option: 0, metadata: "", exec: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgVote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgVote): MsgVote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 proposal_id */ 1:
                    message.proposalId = reader.uint64().toBigInt();
                    break;
                case /* string voter */ 2:
                    message.voter = reader.string();
                    break;
                case /* cosmos.group.v1.VoteOption option */ 3:
                    message.option = reader.int32();
                    break;
                case /* string metadata */ 4:
                    message.metadata = reader.string();
                    break;
                case /* cosmos.group.v1.Exec exec */ 5:
                    message.exec = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgVote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 proposal_id = 1; */
        if (message.proposalId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.proposalId);
        /* string voter = 2; */
        if (message.voter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.voter);
        /* cosmos.group.v1.VoteOption option = 3; */
        if (message.option !== 0)
            writer.tag(3, WireType.Varint).int32(message.option);
        /* string metadata = 4; */
        if (message.metadata !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.metadata);
        /* cosmos.group.v1.Exec exec = 5; */
        if (message.exec !== 0)
            writer.tag(5, WireType.Varint).int32(message.exec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgVote
 */
export const MsgVote = new MsgVote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgVoteResponse$Type extends MessageType<MsgVoteResponse> {
    constructor() {
        super("cosmos.group.v1.MsgVoteResponse", []);
    }
    create(value?: PartialMessage<MsgVoteResponse>): MsgVoteResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgVoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgVoteResponse): MsgVoteResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgVoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgVoteResponse
 */
export const MsgVoteResponse = new MsgVoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExec$Type extends MessageType<MsgExec> {
    constructor() {
        super("cosmos.group.v1.MsgExec", [
            { no: 1, name: "proposal_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } }
        ], { "cosmos.msg.v1.signer": ["signer"] });
    }
    create(value?: PartialMessage<MsgExec>): MsgExec {
        const message = { proposalId: 0n, signer: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExec): MsgExec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 proposal_id */ 1:
                    message.proposalId = reader.uint64().toBigInt();
                    break;
                case /* string signer */ 2:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgExec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 proposal_id = 1; */
        if (message.proposalId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.proposalId);
        /* string signer = 2; */
        if (message.signer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgExec
 */
export const MsgExec = new MsgExec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgExecResponse$Type extends MessageType<MsgExecResponse> {
    constructor() {
        super("cosmos.group.v1.MsgExecResponse", []);
    }
    create(value?: PartialMessage<MsgExecResponse>): MsgExecResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgExecResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgExecResponse): MsgExecResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgExecResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgExecResponse
 */
export const MsgExecResponse = new MsgExecResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLeaveGroup$Type extends MessageType<MsgLeaveGroup> {
    constructor() {
        super("cosmos.group.v1.MsgLeaveGroup", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "group_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "cosmos.msg.v1.signer": ["address"] });
    }
    create(value?: PartialMessage<MsgLeaveGroup>): MsgLeaveGroup {
        const message = { address: "", groupId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgLeaveGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLeaveGroup): MsgLeaveGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 group_id */ 2:
                    message.groupId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLeaveGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 group_id = 2; */
        if (message.groupId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgLeaveGroup
 */
export const MsgLeaveGroup = new MsgLeaveGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLeaveGroupResponse$Type extends MessageType<MsgLeaveGroupResponse> {
    constructor() {
        super("cosmos.group.v1.MsgLeaveGroupResponse", []);
    }
    create(value?: PartialMessage<MsgLeaveGroupResponse>): MsgLeaveGroupResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgLeaveGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLeaveGroupResponse): MsgLeaveGroupResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgLeaveGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.group.v1.MsgLeaveGroupResponse
 */
export const MsgLeaveGroupResponse = new MsgLeaveGroupResponse$Type();
/**
 * @generated ServiceType for protobuf service cosmos.group.v1.Msg
 */
export const Msg = new ServiceType("cosmos.group.v1.Msg", [
    { name: "CreateGroup", options: {}, I: MsgCreateGroup, O: MsgCreateGroupResponse },
    { name: "UpdateGroupMembers", options: {}, I: MsgUpdateGroupMembers, O: MsgUpdateGroupMembersResponse },
    { name: "UpdateGroupAdmin", options: {}, I: MsgUpdateGroupAdmin, O: MsgUpdateGroupAdminResponse },
    { name: "UpdateGroupMetadata", options: {}, I: MsgUpdateGroupMetadata, O: MsgUpdateGroupMetadataResponse },
    { name: "CreateGroupPolicy", options: {}, I: MsgCreateGroupPolicy, O: MsgCreateGroupPolicyResponse },
    { name: "CreateGroupWithPolicy", options: {}, I: MsgCreateGroupWithPolicy, O: MsgCreateGroupWithPolicyResponse },
    { name: "UpdateGroupPolicyAdmin", options: {}, I: MsgUpdateGroupPolicyAdmin, O: MsgUpdateGroupPolicyAdminResponse },
    { name: "UpdateGroupPolicyDecisionPolicy", options: {}, I: MsgUpdateGroupPolicyDecisionPolicy, O: MsgUpdateGroupPolicyDecisionPolicyResponse },
    { name: "UpdateGroupPolicyMetadata", options: {}, I: MsgUpdateGroupPolicyMetadata, O: MsgUpdateGroupPolicyMetadataResponse },
    { name: "SubmitProposal", options: {}, I: MsgSubmitProposal, O: MsgSubmitProposalResponse },
    { name: "WithdrawProposal", options: {}, I: MsgWithdrawProposal, O: MsgWithdrawProposalResponse },
    { name: "Vote", options: {}, I: MsgVote, O: MsgVoteResponse },
    { name: "Exec", options: {}, I: MsgExec, O: MsgExecResponse },
    { name: "LeaveGroup", options: {}, I: MsgLeaveGroup, O: MsgLeaveGroupResponse }
]);
